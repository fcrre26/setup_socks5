#!/bin/bash

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 默认配置
DEFAULT_SOCKS_PORT=20000
DEFAULT_SOCKS_USER="123456"
DEFAULT_SOCKS_PASS="123456"

# 配置文件路径
CONFIG_FILE="/etc/proxy_manager/config.conf"
LOG_FILE="/var/log/proxy_manager.log"

# 日志函数
log_message() {
    local level=$1
    local message=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # 创建日志目录
    mkdir -p "$(dirname $LOG_FILE)"
    
    # 写入日志文件
    echo "[$timestamp] [$level] $message" >> "$LOG_FILE"
    
    # 终端输出
    case $level in
        ERROR) echo -e "${RED}$message${NC}" ;;
        WARN)  echo -e "${YELLOW}$message${NC}" ;;
        INFO)  echo -e "${GREEN}$message${NC}" ;;
        *)     echo -e "$message" ;;
    esac
}

# 使用说明
show_usage() {
    log_message "INFO" "=== 代理服务器配置流程 ==="
    echo -e "推荐配置顺序："
    echo -e "1. 环境配置 - 安装必要的软件包和服务"
    echo -e "2. BBR加速 - 优化网络性能"
    echo -e "3. IPv6管理 - 配置IPv6地址（可选）"
    echo -e "4. 带宽控制 - 设置流量限制"
    echo -e "5. SOCKS5设置 - 配置代理服务"
    echo -e "6. IP策略 - 设置进出流量规则"
    echo -e "7. 连通性测试 - 验证代理是否正常工作"
    echo -e "${GREEN}提示：首次使用请按照顺序依次配置${NC}"
    echo -e "${RED}注意：清除规则(选项9)会重置所有设置${NC}\n"
}

# 配置管理函数
init_config() {
    # 创建配置目录
    mkdir -p "$(dirname $CONFIG_FILE)"
    
    # 如果配置文件不存在，创建默认配置
    if [ ! -f "$CONFIG_FILE" ]; then
        cat <<EOF > "$CONFIG_FILE"
SOCKS_PORT=$DEFAULT_SOCKS_PORT
SOCKS_USER=$DEFAULT_SOCKS_USER
SOCKS_PASS=$DEFAULT_SOCKS_PASS
EOF
        log_message "INFO" "已创建默认配置文件"
    fi
    
    # 加载配置
    source "$CONFIG_FILE"
}

# 保存配置
save_config() {
    cat <<EOF > "$CONFIG_FILE"
SOCKS_PORT=$socks_port
SOCKS_USER=$socks_user
SOCKS_PASS=$socks_pass
EOF
    log_message "INFO" "配置已保存"
}

# 重置为默认配置
reset_config() {
    socks_port=$DEFAULT_SOCKS_PORT
    socks_user=$DEFAULT_SOCKS_USER
    socks_pass=$DEFAULT_SOCKS_PASS
    save_config
    log_message "INFO" "已重置为默认配置"
}

# 配置文件备份函数
backup_config() {
    local backup_dir="/etc/xray/backups"
    local timestamp=$(date '+%Y%m%d_%H%M%S')
    
    mkdir -p "$backup_dir"
    
    # 备份 Xray 配置
    if [ -f "/etc/xray/serve.json" ]; then
        cp /etc/xray/serve.json "$backup_dir/serve.json.$timestamp"
        log_message "INFO" "已备份 Xray 配置到 $backup_dir/serve.json.$timestamp"
    fi
    
    # 备份代理管理器配置
    if [ -f "$CONFIG_FILE" ]; then
        cp "$CONFIG_FILE" "$backup_dir/proxy_config.$timestamp"
        log_message "INFO" "已备份代理配置到 $backup_dir/proxy_config.$timestamp"
    fi
    
    # 保留最近10个备份
    for type in serve.json proxy_config; do
        ls -t "$backup_dir/$type."* 2>/dev/null | tail -n +11 | xargs -I {} rm {} 2>/dev/null
    done
}

# 恢复配置文件函数
restore_config() {
    local backup_dir="/etc/xray/backups"
    
    if [ ! -d "$backup_dir" ]; then
        log_message "ERROR" "备份目录不存在"
        return 1
    fi
    
    echo "可用的备份文件："
    ls -lt "$backup_dir" | grep -v '^total' | awk '{print NR". "$9}'
    
    read -p "请选择要恢复的备份文件编号: " number
    local file=$(ls -t "$backup_dir" | sed -n "${number}p")
    
    if [ -z "$file" ]; then
        log_message "ERROR" "无效的选择"
        return 1
    fi
    
    if [[ $file == serve.json.* ]]; then
        cp "$backup_dir/$file" /etc/xray/serve.json
        log_message "INFO" "已恢复 Xray 配置"
    elif [[ $file == proxy_config.* ]]; then
        cp "$backup_dir/$file" "$CONFIG_FILE"
        log_message "INFO" "已恢复代理配置"
    fi
}

# 系统检测模块
detect_system() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        case "$ID" in
            "ubuntu"|"debian")
                service_manager="systemctl"
                log_message "INFO" "检测到 $ID 系统"
                ;;
            "centos")
                if (( $(echo "$VERSION_ID >= 7" | bc -l) )); then
                    service_manager="systemctl"
                else
                    service_manager="service"
                fi
                log_message "INFO" "检测到 CentOS $VERSION_ID"
                ;;
            *)
                log_message "ERROR" "不支持的系统: $ID"
                return 1
                ;;
        esac
    else
        log_message "ERROR" "无法识别的系统"
        return 1
    fi
}

# 软件安装模块
check_and_install_unzip() {
    if ! command -v unzip &> /dev/null; then
        log_message "INFO" "正在安装 unzip..."
        if [ "$ID" == "centos" ]; then
            yum install unzip -y
        else
            apt-get update && apt-get install unzip -y
        fi
    fi
    return 0
}

check_and_install_iptables() {
    if ! command -v iptables &> /dev/null; then
        log_message "INFO" "正在安装 iptables..."
        if [ "$ID" == "centos" ]; then
            yum install iptables-services -y
            systemctl enable iptables
        else
            apt-get update && apt-get install iptables-persistent -y
        fi
    fi
    return 0
}

# 系统检查模块
check_ipv6() {
    if ! sysctl -a 2>/dev/null | grep -q "net.ipv6.conf.all.disable_ipv6 = 0"; then
        log_message "INFO" "启用 IPv6 支持..."
        sysctl -w net.ipv6.conf.all.disable_ipv6=0
        sysctl -w net.ipv6.conf.default.disable_ipv6=0
        echo "net.ipv6.conf.all.disable_ipv6 = 0" >> /etc/sysctl.conf
        echo "net.ipv6.conf.default.disable_ipv6 = 0" >> /etc/sysctl.conf
        sysctl -p
    fi
    return 0
}

# Xray安装模块
install_xray() {
    log_message "INFO" "正在从 GitHub 下载 Xray..."
    check_and_install_unzip
    
    # 下载前备份
    if [ -f "/usr/local/bin/xray" ]; then
        backup_config
    fi
    
    wget --no-check-certificate -O /tmp/xray.zip "https://github.com/XTLS/Xray-core/releases/latest/download/Xray-linux-64.zip"
    if [ $? -ne 0 ]; then
        log_message "ERROR" "Xray 下载失败"
        return 1
    fi
    
    unzip -o /tmp/xray.zip -d /usr/local/bin
    rm -f /tmp/xray.zip
    chmod +x /usr/local/bin/xray
    
    log_message "INFO" "Xray 安装完成"
    return 0
}

# 环境配置模块
setup_environment() {
    log_message "INFO" "开始环境配置..."
    
    # 设置防火墙规则
    log_message "INFO" "配置防火墙规则..."
    iptables -P INPUT ACCEPT
    iptables -P FORWARD ACCEPT
    iptables -P OUTPUT ACCEPT
    iptables -t nat -F
    iptables -t mangle -F
    iptables -F
    iptables -X
    iptables-save
    
    # 安装 Xray
    install_xray || return 1
    
    # 创建 Xray 服务文件
    log_message "INFO" "创建 Xray 服务文件..."
    cat <<EOF > /etc/systemd/system/xray.service
[Unit]
Description=The Xray Proxy Server
After=network-online.target

[Service]
ExecStart=/usr/local/bin/xray -c /etc/xray/serve.json
ExecStop=/bin/kill -s QUIT \$MAINPID
Restart=always
RestartSec=15s

[Install]
WantedBy=multi-user.target
EOF

    # 启动 Xray 服务
    log_message "INFO" "启动 Xray 服务..."
    $service_manager daemon-reload
    $service_manager enable xray
    $service_manager start xray
    
    if ! systemctl is-active --quiet xray; then
        log_message "ERROR" "Xray 服务启动失败"
        return 1
    fi
    
    log_message "INFO" "环境配置完成"
    return 0
}

# BBR 加速模块
enable_bbr() {
    log_message "INFO" "正在检查 BBR 支持..."
    
    if ! sysctl net.ipv4.tcp_available_congestion_control | grep -q "bbr"; then
        log_message "ERROR" "当前内核不支持 BBR，请升级内核"
        return 1
    fi
    
    # 备份当前配置
    cp /etc/sysctl.conf /etc/sysctl.conf.bak
    
    # 设置 BBR
    echo "net.core.default_qdisc=fq" >> /etc/sysctl.conf
    echo "net.ipv4.tcp_congestion_control=bbr" >> /etc/sysctl.conf
    
    sysctl -p
    
    if sysctl net.ipv4.tcp_congestion_control | grep -q "bbr"; then
        log_message "INFO" "BBR 已成功启用"
    else
        log_message "ERROR" "BBR 启用失败"
        # 恢复备份
        mv /etc/sysctl.conf.bak /etc/sysctl.conf
        return 1
    fi
    
    return 0
}

# IPv6相关函数
generate_random_hex() {
    local length=$1
    head -c $((length/2)) /dev/urandom | hexdump -ve '1/1 "%.2x"'
}

get_main_interface() {
    MAIN_INTERFACE=$(ip route | grep default | awk '{print $5}' | head -n1)
    if [ -z "$MAIN_INTERFACE" ]; then
        log_message "ERROR" "无法检测到主网卡"
        return 1
    fi
    log_message "INFO" "检测到主网卡: $MAIN_INTERFACE"
    echo $MAIN_INTERFACE
}

get_ipv6_prefix() {
    local interface=$1
    
    # 获取非本地IPv6地址
    local current_ipv6=$(ip -6 addr show dev $interface | grep "scope global" | grep -v "temporary" | head -n1 | awk '{print $2}')
    
    if [ -z "$current_ipv6" ]; then
        log_message "ERROR" "未检测到IPv6地址"
        return 1
    fi
    
    # 从CIDR格式中提取地址部分
    local ipv6_addr=$(echo "$current_ipv6" | cut -d'/' -f1)
    
    # 提取前缀（前64位）
    local prefix=$(echo "$ipv6_addr" | sed -E 's/:[^:]+:[^:]+:[^:]+:[^:]+$/::/')
    
    if [ -z "$prefix" ]; then
        log_message "ERROR" "无法提取IPv6前缀"
        return 1
    fi
    
    echo "$prefix"
}

add_ipv6_addresses() {
    local interface=$1
    local prefix=$2
    local num=$3
    
    # 配置文件路径
    local IPV6_CONFIG="/etc/network/interfaces.d/60-ipv6-addresses"
    
    # 备份当前配置
    if [ -f "$IPV6_CONFIG" ]; then
        cp "$IPV6_CONFIG" "${IPV6_CONFIG}.bak"
        log_message "INFO" "已备份IPv6配置文件"
    fi
    
    log_message "INFO" "准备添加IPv6地址:"
    log_message "INFO" "接口: $interface"
    log_message "INFO" "前缀: $prefix"
    log_message "INFO" "数量: $num"
    
    # 获取现有地址列表
    declare -A existing_addresses
    while read -r addr; do
        existing_addresses["$addr"]=1
    done < <(ip -6 addr show dev $interface | grep "inet6" | grep -v "fe80" | awk '{print $2}' | cut -d'/' -f1)
    
    count=0
    attempts=0
    max_attempts=$((num * 3))
    
    # 创建新的配置文件
    echo "# IPv6 Addresses - Generated by proxy manager" > "$IPV6_CONFIG"
    
    while [ $count -lt $num ] && [ $attempts -lt $max_attempts ]; do
        ((attempts++))
        
        # 生成随机后缀
        suffix=$(printf "%04x:%04x:%04x:%04x" \
            $((RANDOM % 65536)) \
            $((RANDOM % 65536)) \
            $((RANDOM % 65536)) \
            $((RANDOM % 65536)))
        
        NEW_IPV6="${prefix%::}:${suffix}"
        
        if [ "${existing_addresses[$NEW_IPV6]}" == "1" ]; then
            log_message "WARN" "地址已存在: $NEW_IPV6"
            continue
        fi
        
        if ip -6 addr add "$NEW_IPV6/64" dev "$interface" 2>/dev/null; then
            log_message "INFO" "成功添加IPv6地址: $NEW_IPV6"
            existing_addresses["$NEW_IPV6"]=1
            ((count++))
            
            # 添加到持久化配置
            echo "" >> "$IPV6_CONFIG"
            echo "iface $interface inet6 static" >> "$IPV6_CONFIG"
            echo "    address $NEW_IPV6/64" >> "$IPV6_CONFIG"
        else
            log_message "ERROR" "添加地址失败: $NEW_IPV6"
        fi
    done
    
    if [ $count -lt $num ]; then
        log_message "WARN" "只成功添加了 $count 个地址（目标: $num）"
    fi
    
    # 更新网络接口配置
    if ! grep -q "source /etc/network/interfaces.d/*" /etc/network/interfaces; then
        echo "source /etc/network/interfaces.d/*" >> /etc/network/interfaces
        log_message "INFO" "已更新网络接口配置"
    fi
    
    log_message "INFO" "IPv6地址配置完成"
}

delete_all_ipv6() {
    local interface=$1
    local IPV6_CONFIG="/etc/network/interfaces.d/60-ipv6-addresses"
    
    # 备份配置文件
    if [ -f "$IPV6_CONFIG" ]; then
        cp "$IPV6_CONFIG" "${IPV6_CONFIG}.bak"
        rm -f "$IPV6_CONFIG"
        log_message "INFO" "已删除IPv6配置文件"
    fi
    
    # 删除所有IPv6地址
    for addr in $(ip -6 addr show dev $interface | grep "inet6" | grep -v "fe80" | awk '{print $2}'); do
        ip -6 addr del $addr dev $interface
        log_message "INFO" "已删除IPv6地址: $addr"
    done
    
    log_message "INFO" "所有配置的IPv6地址已删除"
}

show_current_ipv6() {
    local interface=$1
    log_message "INFO" "当前IPv6地址列表："
    local ipv6_list=$(ip -6 addr show dev $interface | grep "inet6" | grep -v "fe80")
    if [ -z "$ipv6_list" ]; then
        log_message "WARN" "未检测到任何IPv6地址"
        return 1
    fi
    echo "$ipv6_list"
}

# 带宽控制模块
setup_bandwidth_control() {
    log_message "INFO" "开始配置带宽控制..."
    
    # 获取网络接口信息
    get_active_interfaces
    local active_ip_count=$(get_active_ip_count)
    
    if [ $active_ip_count -eq 0 ]; then
        log_message "ERROR" "未检测到活动IP"
        return 1
    fi
    
    read -p "请输入VPS的总带宽（例如50M）: " total_bandwidth
    
    if [[ ! $total_bandwidth =~ ^[0-9]+M$ ]]; then
        log_message "ERROR" "带宽格式错误，请使用类似'50M'的格式"
        return 1
    fi
    
    # 计算每个IP的带宽限制
    local rate=$(echo "${total_bandwidth%M} / $active_ip_count" | bc)Mbit
    
    log_message "INFO" "配置带宽控制规则..."
    for interface in $interfaces; do
        # 清除现有规则
        tc qdisc del dev $interface root 2>/dev/null
        
        # 添加新规则
        tc qdisc add dev $interface root handle 1: htb default 30
        tc class add dev $interface parent 1: classid 1:1 htb rate $total_bandwidth
        
        # 为每个IP配置带宽限制
        for ip in $(hostname -I); do
            tc class add dev $interface parent 1:1 classid 1:10 htb rate ${rate} ceil ${rate}
            tc filter add dev $interface protocol ip parent 1:0 prio 1 u32 match ip dst $ip flowid 1:10
            log_message "INFO" "已为 $ip 设置带宽限制: ${rate}"
        done
    done
    
    log_message "INFO" "带宽控制配置完成"
    return 0
}

# IP策略配置模块
set_ip_strategy() {
    log_message "INFO" "配置IP策略..."
    
    echo -e "\n${YELLOW}可用的IP策略：${NC}"
    echo "1. 同IP进，同IP出"
    echo "2. IPv4进，随机IPv4出"
    echo "3. IPv4进，随机IPv6出"
    echo "4. IPv4进，不同端口对应固定IPv6出"
    
    read -p "请选择IP策略 [1-4]: " strategy
    
    # 获取系统IP地址
    ipv4_addrs=($(hostname -I | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}'))
    ipv6_addrs=($(hostname -I | grep -oE '([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}'))
    
    # 如果选择策略4，需要配置端口映射
    declare -A port_map
    if [ "$strategy" = "4" ]; then
        read -p "请输入需要的端口数量: " port_count
        start_port=$socks_port
        
        for ((i=0; i<port_count; i++)); do
            current_port=$((start_port + i))
            if [ $i -lt ${#ipv6_addrs[@]} ]; then
                port_map[$current_port]=${ipv6_addrs[$i]}
                echo "端口 $current_port -> ${ipv6_addrs[$i]}"
            else
                log_message "WARN" "IPv6地址不足，跳过端口 $current_port"
                break
            fi
        done
    fi
    
    configure_ip_strategy "$strategy" port_map
}

# 获取活动IP数量函数
get_active_ip_count() {
    local count=$(hostname -I | wc -w)
    echo $count
}

# 获取活动网络接口函数
get_active_interfaces() {
    interfaces=$(ip link show | grep -E '^[0-9]+:' | grep -v 'lo:' | cut -d: -f2 | tr -d ' ')
    echo $interfaces
}

configure_ip_strategy() {
    local strategy=$1
    local -n port_map=$2
    
    log_message "INFO" "开始配置IP策略..."
    
    # 检查必要条件
    if [ ${#ipv4_addrs[@]} -eq 0 ]; then
        log_message "ERROR" "没有可用的IPv4地址"
        return 1
    }
    
    # 备份当前配置
    backup_config
    
    # 创建配置目录
    mkdir -p /etc/xray
    
    # 生成配置文件
    log_message "INFO" "正在生成新的配置文件..."
    
    case $strategy in
        1)  # 同IP进同IP出
            cat <<EOF > /etc/xray/serve.json
{
    "inbounds": [
EOF
            first=true
            for ipv4 in "${ipv4_addrs[@]}"; do
                if [ "$first" = true ]; then
                    first=false
                else
                    echo "," >> /etc/xray/serve.json
                fi
                
                cat <<EOF >> /etc/xray/serve.json
        {
            "listen": "$ipv4",
            "port": $socks_port,
            "protocol": "socks",
            "tag": "in_$ipv4",
            "settings": {
                "auth": "password",
                "udp": true,
                "ip": "$ipv4",
                "accounts": [
                    {
                        "user": "$socks_user",
                        "pass": "$socks_pass"
                    }
                ]
            }
        }
EOF
            done

            cat <<EOF >> /etc/xray/serve.json
    ],
    "outbounds": [
EOF
            first=true
            for ipv4 in "${ipv4_addrs[@]}"; do
                if [ "$first" = true ]; then
                    first=false
                else
                    echo "," >> /etc/xray/serve.json
                fi
                
                cat <<EOF >> /etc/xray/serve.json
        {
            "protocol": "freedom",
            "tag": "out_$ipv4",
            "settings": {
                "domainStrategy": "UseIPv4"
            },
            "streamSettings": {
                "sockopt": {
                    "mark": 255
                }
            },
            "sendThrough": "$ipv4"
        }
EOF
            done

            cat <<EOF >> /etc/xray/serve.json
    ],
    "routing": {
        "rules": [
EOF
            first=true
            for ipv4 in "${ipv4_addrs[@]}"; do
                if [ "$first" = true ]; then
                    first=false
                else
                    echo "," >> /etc/xray/serve.json
                fi
                
                cat <<EOF >> /etc/xray/serve.json
            {
                "type": "field",
                "inboundTag": ["in_$ipv4"],
                "outboundTag": "out_$ipv4"
            }
EOF
            done

            cat <<EOF >> /etc/xray/serve.json
        ]
    }
}
EOF
            ;;
            
        2)  # IPv4进随机IPv4出
            cat <<EOF > /etc/xray/serve.json
{
    "inbounds": [
EOF
            first=true
            for ipv4 in "${ipv4_addrs[@]}"; do
                if [ "$first" = true ]; then
                    first=false
                else
                    echo "," >> /etc/xray/serve.json
                fi
                
                cat <<EOF >> /etc/xray/serve.json
        {
            "listen": "$ipv4",
            "port": $socks_port,
            "protocol": "socks",
            "tag": "in_$ipv4",
            "settings": {
                "auth": "password",
                "udp": true,
                "ip": "$ipv4",
                "accounts": [
                    {
                        "user": "$socks_user",
                        "pass": "$socks_pass"
                    }
                ]
            }
        }
EOF
            done

            cat <<EOF >> /etc/xray/serve.json
    ],
    "outbounds": [
EOF
            first=true
            for ipv4 in "${ipv4_addrs[@]}"; do
                if [ "$first" = true ]; then
                    first=false
                else
                    echo "," >> /etc/xray/serve.json
                fi
                
                cat <<EOF >> /etc/xray/serve.json
        {
            "protocol": "freedom",
            "tag": "out_$ipv4",
            "settings": {
                "domainStrategy": "UseIPv4"
            },
            "streamSettings": {
                "sockopt": {
                    "mark": 255
                }
            },
            "sendThrough": "$ipv4"
        }
EOF
            done

            cat <<EOF >> /etc/xray/serve.json
    ],
    "routing": {
        "balancers": [
            {
                "tag": "ipv4_balancer",
                "selector": [$(printf '"out_%s",' "${ipv4_addrs[@]}" | sed 's/,$//')],
                "strategy": "random"
            }
        ],
        "rules": [
EOF
            first=true
            for ipv4 in "${ipv4_addrs[@]}"; do
                if [ "$first" = true ]; then
                    first=false
                else
                    echo "," >> /etc/xray/serve.json
                fi
                
                cat <<EOF >> /etc/xray/serve.json
            {
                "type": "field",
                "inboundTag": ["in_$ipv4"],
                "balancerTag": "ipv4_balancer"
            }
EOF
            done

            cat <<EOF >> /etc/xray/serve.json
        ]
    }
}
EOF
            ;;
        3)  # IPv4进随机IPv6出
            # 检查IPv6地址
            if [ ${#ipv6_addrs[@]} -eq 0 ]; then
                log_message "ERROR" "没有可用的IPv6地址"
                return 1
            }
            
            # 随机排序IPv6地址
            ipv6_shuffled=($(printf "%s\n" "${ipv6_addrs[@]}" | shuf))
            outbound_tags=()
            for ipv6 in "${ipv6_shuffled[@]}"; do
                outbound_tags+=("outbound_$(echo $ipv6 | tr ':.' '_')")
            done
            
            cat <<EOF > /etc/xray/serve.json
{
    "inbounds": [
        {
            "listen": "${ipv4_addrs[0]}",
            "port": $socks_port,
            "protocol": "socks",
            "tag": "inbound-ipv4",
            "settings": {
                "auth": "password",
                "udp": true,
                "accounts": [
                    {
                        "user": "$socks_user",
                        "pass": "$socks_pass"
                    }
                ]
            }
        }
    ],
    "outbounds": [
EOF
            first=true
            for i in "${!ipv6_shuffled[@]}"; do
                ipv6=${ipv6_shuffled[$i]}
                tag=${outbound_tags[$i]}
                
                if [ "$first" = true ]; then
                    first=false
                else
                    echo "," >> /etc/xray/serve.json
                fi
                
                cat <<EOF >> /etc/xray/serve.json
        {
            "protocol": "freedom",
            "tag": "$tag",
            "settings": {
                "domainStrategy": "UseIPv6"
            },
            "streamSettings": {
                "sockopt": {
                    "mark": 255
                }
            },
            "sendThrough": "$ipv6"
        }
EOF
            done

            cat <<EOF >> /etc/xray/serve.json
    ],
    "routing": {
        "balancers": [
            {
                "tag": "ipv6_balancer",
                "selector": [$(printf '"%s",' "${outbound_tags[@]}" | sed 's/,$//')],
                "strategy": "random"
            }
        ],
        "rules": [
            {
                "type": "field",
                "inboundTag": ["inbound-ipv4"],
                "balancerTag": "ipv6_balancer"
            }
        ]
    }
}
EOF
            ;;
            
        4)  # IPv4进，不同端口对应固定IPv6出
            cat <<EOF > /etc/xray/serve.json
{
    "inbounds": [
EOF
            first_inbound=true
            for port in "${!port_map[@]}"; do
                ipv6=${port_map[$port]}
                for ipv4 in "${ipv4_addrs[@]}"; do
                    if [ "$first_inbound" = true ]; then
                        first_inbound=false
                    else
                        echo "," >> /etc/xray/serve.json
                    fi
                    
                    cat <<EOF >> /etc/xray/serve.json
        {
            "listen": "$ipv4",
            "port": $port,
            "protocol": "socks",
            "tag": "in_${port}_${ipv4}",
            "settings": {
                "auth": "password",
                "udp": true,
                "ip": "$ipv4",
                "accounts": [
                    {
                        "user": "$socks_user",
                        "pass": "$socks_pass"
                    }
                ]
            }
        }
EOF
                done
            done

            cat <<EOF >> /etc/xray/serve.json
    ],
    "outbounds": [
EOF
            first_outbound=true
            for port in "${!port_map[@]}"; do
                ipv6=${port_map[$port]}
                if [ "$first_outbound" = true ]; then
                    first_outbound=false
                else
                    echo "," >> /etc/xray/serve.json
                fi
                
                cat <<EOF >> /etc/xray/serve.json
        {
            "protocol": "freedom",
            "tag": "out_${port}",
            "settings": {
                "domainStrategy": "UseIPv6"
            },
            "streamSettings": {
                "sockopt": {
                    "mark": 255
                }
            },
            "sendThrough": "$ipv6"
        }
EOF
            done

            cat <<EOF >> /etc/xray/serve.json
    ],
    "routing": {
        "rules": [
EOF
            first_rule=true
            for port in "${!port_map[@]}"; do
                for ipv4 in "${ipv4_addrs[@]}"; do
                    if [ "$first_rule" = true ]; then
                        first_rule=false
                    else
                        echo "," >> /etc/xray/serve.json
                    fi
                    
                    cat <<EOF >> /etc/xray/serve.json
            {
                "type": "field",
                "inboundTag": ["in_${port}_${ipv4}"],
                "outboundTag": "out_${port}"
            }
EOF
                done
            done

            cat <<EOF >> /etc/xray/serve.json
        ]
    }
}
EOF
            ;;
            
        *)
            log_message "ERROR" "无效的策略选择"
            return 1
            ;;
    esac
    
    # 验证配置
    log_message "INFO" "验证配置文件..."
    if ! /usr/local/bin/xray -test -config /etc/xray/serve.json; then
        log_message "ERROR" "配置验证失败"
        return 1
    fi
    
    # 重启 Xray 服务
    log_message "INFO" "重启 Xray 服务..."
    systemctl restart xray
    sleep 2
    
    if ! systemctl is-active --quiet xray; then
        log_message "ERROR" "Xray 服务启动失败"
        systemctl status xray
        return 1
    fi
    
    log_message "INFO" "IP策略设置完成并成功启动服务"
    return 0
}

# SOCKS5代理设置
set_socks5_credentials() {
    log_message "INFO" "配置SOCKS5代理..."
    
    echo -e "${YELLOW}当前配置：${NC}"
    echo "端口: ${socks_port:-$DEFAULT_SOCKS_PORT}"
    echo "用户名: ${socks_user:-$DEFAULT_SOCKS_USER}"
    echo "密码: ${socks_pass:-$DEFAULT_SOCKS_PASS}"
    echo ""
    
    read -p "是否使用默认配置？(y/n) [y]: " use_default
    use_default=${use_default:-y}
    
    if [[ $use_default =~ ^[Yy]$ ]]; then
        socks_port=$DEFAULT_SOCKS_PORT
        socks_user=$DEFAULT_SOCKS_USER
        socks_pass=$DEFAULT_SOCKS_PASS
        log_message "INFO" "使用默认配置"
    else
        read -p "请输入SOCKS5起始端口 [$DEFAULT_SOCKS_PORT]: " input_port
        read -p "请输入用户名 [$DEFAULT_SOCKS_USER]: " input_user
        read -p "请输入密码 [$DEFAULT_SOCKS_PASS]: " input_pass
        
        socks_port=${input_port:-$DEFAULT_SOCKS_PORT}
        socks_user=${input_user:-$DEFAULT_SOCKS_USER}
        socks_pass=${input_pass:-$DEFAULT_SOCKS_PASS}
    fi
    
    save_config
    set_ip_strategy
    generate_proxy_list "$socks_port" "$socks_user" "$socks_pass"
    log_message "INFO" "SOCKS5配置已更新"
    return 0
}

# 测试代理连通性
test_proxy_connectivity() {
    log_message "INFO" "开始测试代理连通性..."
    
    if [ ! -f /root/proxy_list.txt ]; then
        log_message "ERROR" "/root/proxy_list.txt 文件不存在"
        return 1
    fi
    
    while IFS= read -r line; do
        if [[ $line =~ ^(.+):([0-9]+):(.+):(.+)$ ]]; then
            ip="${BASH_REMATCH[1]}"
            port="${BASH_REMATCH[2]}"
            user="${BASH_REMATCH[3]}"
            pass="${BASH_REMATCH[4]}"
            
            log_message "INFO" "测试 $ip:$port..."
            
            if [[ $ip == *:* ]]; then
                ip="[$ip]"
            fi
            
            if curl -s --proxy socks5h://$user:$pass@$ip:$port http://httpbin.org/ip -o /dev/null; then
                log_message "INFO" "$ip:$port 代理连接成功"
            else
                log_message "ERROR" "$ip:$port 代理连接失败"
            fi
        else
            log_message "ERROR" "行格式不正确: $line"
        fi
    done < /root/proxy_list.txt
    
    log_message "INFO" "代理连通性测试完成"
    return 0
}

# 清理函数
clear_proxy_rules() {
    log_message "INFO" "开始清除所有代理规则..."
    
    # 停止并禁用服务
    $service_manager stop xray
    $service_manager disable xray
    
    # 删除配置文件
    rm -f /etc/xray/serve.json
    rm -f /etc/systemd/system/xray.service
    
    # 清除防火墙规则
    iptables -F
    iptables -X
    iptables -t nat -F
    iptables -t mangle -F
    ip6tables -F
    ip6tables -X
    ip6tables -t nat -F
    ip6tables -t mangle -F
    iptables-save
    ip6tables-save
    
    # 删除代理列表
    rm -f /root/proxy_list.txt
    
    log_message "INFO" "已清除所有代理规则，回到未安装SOCKS5代理的状态"
    return 0
}

# 代理列表生成
generate_proxy_list() {
    local socks_port=$1
    local socks_user=$2
    local socks_pass=$3
    
    log_message "INFO" "生成新的代理列表文件..."
    
    # 清空原有内容
    : > /root/proxy_list.txt
    
    # 获取当前IP策略配置
    local strategy=$(grep -A1 '"rules":' /etc/xray/serve.json | grep -o '"balancerTag": ".*"' | cut -d'"' -f4)
    
    # 写入新的代理列表
    echo "# 代理服务器列表 - 格式：入口IP:端口:用户名:密码:出口IP" > /root/proxy_list.txt
    
    case $strategy in
        "ipv4_balancer")
            echo "# IPv4进随机IPv4出（不重复直到耗尽）" >> /root/proxy_list.txt
            local ipv4_addrs=($(hostname -I | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}'))
            for ip in "${ipv4_addrs[@]}"; do
                other_ips=$(echo "${ipv4_addrs[@]/$ip/}" | tr ' ' ',')
                echo "$ip:$socks_port:$socks_user:$socks_pass:$other_ips" >> /root/proxy_list.txt
            done
            ;;
            
        "ipv6_balancer")
            echo "# IPv4进随机IPv6出（不重复直到耗尽）" >> /root/proxy_list.txt
            local ipv4_addrs=($(hostname -I | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}'))
            local ipv6_addrs=($(hostname -I | grep -oE '([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}'))
            for ip in "${ipv4_addrs[@]}"; do
                ipv6_list=$(echo "${ipv6_addrs[@]}" | tr ' ' ',')
                echo "$ip:$socks_port:$socks_user:$socks_pass:$ipv6_list" >> /root/proxy_list.txt
            done
            ;;
            
        *)
            if grep -q "in_[0-9]*_" /etc/xray/serve.json; then
                echo "# IPv4进固定端口对应固定IPv6出" >> /root/proxy_list.txt
                local ipv4_addrs=($(hostname -I | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}'))
                while read -r port ipv6; do
                    for ip in "${ipv4_addrs[@]}"; do
                        echo "$ip:$port:$socks_user:$socks_pass:$ipv6" >> /root/proxy_list.txt
                    done
                done < <(grep -A5 "sendThrough" /etc/xray/serve.json | grep -B4 "mark.*255" | grep -E '"port"|"sendThrough"' | paste - - | sed -E 's/.*port": ([0-9]+).*sendThrough": "([^"]+).*/\1 \2/')
            else
                echo "# 同IP进出（默认）" >> /root/proxy_list.txt
                local ips=($(hostname -I))
                for ip in "${ips[@]}"; do
                    echo "$ip:$socks_port:$socks_user:$socks_pass:$ip" >> /root/proxy_list.txt
                done
            fi
            ;;
    esac
    
    log_message "INFO" "新的代理列表已生成：/root/proxy_list.txt"
    return 0
}

# 添加在 clear_proxy_rules() 函数之后
ipv6_manager_menu() {
    echo -e "\n${YELLOW}=== IPv6地址管理 ===${NC}"
    echo "1. 添加IPv6地址"
    echo "2. 删除所有IPv6地址"
    echo "3. 显示当前IPv6地址"
    echo "4. 返回主菜单"

    read -p "请选择操作 [1-4]: " choice
    case $choice in
        1)
            interface=$(get_main_interface)
            if [ $? -eq 0 ]; then
                prefix=$(get_ipv6_prefix "$interface")
                if [ $? -eq 0 ]; then
                    read -p "请输入要添加的IPv6地址数量: " num_addresses
                    add_ipv6_addresses "$interface" "$prefix" "$num_addresses"
                fi
            fi
            ;;
        2)
            interface=$(get_main_interface)
            [ $? -eq 0 ] && delete_all_ipv6 "$interface"
            ;;
        3)
            interface=$(get_main_interface)
            [ $? -eq 0 ] && show_current_ipv6 "$interface"
            ;;
        4)
            return 0
            ;;
        *)
            log_message "ERROR" "无效选项"
            ;;
    esac
}


# 主菜单
show_menu() {
    echo -e "\n${YELLOW}=== 代理服务器管理工具 ===${NC}"
    echo "1. 环境配置（安装必要组件）"
    echo "2. 启用BBR加速"
    echo "3. IPv6地址管理"
    echo "4. 设置带宽控制"
    echo "5. SOCKS5代理设置"
    echo "6. 设置IP进出策略"
    echo "7. 测试代理连通性"
    echo "8. 显示代理列表"
    echo "9. 清除所有代理规则"
    echo "10. 重置为默认配置"
    echo "11. 备份当前配置"
    echo "12. 恢复配置备份"
    echo "13. 查看操作日志"
    echo "14. 退出"

    read -p "请输入选项 [1-14]: " option
    case $option in
        1) setup_environment ;;
        2) enable_bbr ;;
        3) ipv6_manager_menu ;;
        4) setup_bandwidth_control ;;
        5) set_socks5_credentials ;;
        6) set_ip_strategy ;;
        7) test_proxy_connectivity ;;
        8) 
            if [ -f /root/proxy_list.txt ]; then
                cat /root/proxy_list.txt
            else
                log_message "ERROR" "/root/proxy_list.txt 文件不存在"
            fi
            ;;
        9) clear_proxy_rules ;;
        10) reset_config ;;
        11) backup_config ;;
        12) restore_config ;;
        13) 
            if [ -f "$LOG_FILE" ]; then
                less "$LOG_FILE"
            else
                log_message "ERROR" "日志文件不存在"
            fi
            ;;
        14) 
            log_message "INFO" "退出脚本"
            exit 
            ;;
        *) log_message "ERROR" "无效选项，请输入1-14之间的数字" ;;
    esac
}

# 主程序
main() {
    # 检查root权限
    if [ "$EUID" -ne 0 ]; then 
        log_message "ERROR" "请使用root权限运行此脚本"
        exit 1
    fi
    
    # 初始化配置
    init_config
    
    # 系统检测
    detect_system
    if [ $? -ne 0 ]; then
        log_message "ERROR" "系统检测失败，请检查您的操作系统是否受支持"
        exit 1
    fi
    
    check_and_install_iptables
    check_ipv6
    
    # 显示使用说明
    show_usage
    
    # 主循环
    while true; do
        show_menu
        sleep 1
    done
}

# 运行主程序
main
