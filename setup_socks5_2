################################################################################
#                             基础设置模块 - 完整版                              #
################################################################################

#!/bin/bash

# 配置文件和目录定义
CONFIG_ROOT="/etc/proxy_manager"
CONFIG_DIR="$CONFIG_ROOT/config"
LOG_DIR="$CONFIG_ROOT/logs"
TRACK_DIR="$CONFIG_ROOT/track"
XRAY_CONFIG_DIR="/etc/xray"
PROXY_LIST="/root/proxy_list.txt"
LOG_FILE="$LOG_DIR/proxy_manager.log"
ERROR_LOG="$LOG_DIR/error.log"
STATUS_FILE="$CONFIG_DIR/status.json"

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 初始化函数
init_directories() {
    local dirs=("$CONFIG_ROOT" "$CONFIG_DIR" "$LOG_DIR" "$TRACK_DIR" "$XRAY_CONFIG_DIR")
    for dir in "${dirs[@]}"; do
        if [ ! -d "$dir" ]; then
            mkdir -p "$dir"
            if [ $? -ne 0 ]; then
                echo -e "${RED}错误: 无法创建目录 $dir${NC}"
                return 1
            fi
        fi
    done
    
    # 设置适当的权限
    chmod 700 "$CONFIG_ROOT"
    chmod 700 "$CONFIG_DIR"
    chmod 755 "$LOG_DIR"
    chmod 700 "$TRACK_DIR"
    return 0
}

# 系统依赖检查
check_dependencies() {
    local deps=("curl" "bc" "wget" "iptables" "ip6tables" "unzip")
    local missing_deps=()

    for dep in "${deps[@]}"; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            missing_deps+=("$dep")
        fi
    done

    if [ ${#missing_deps[@]} -ne 0 ]; then
        echo -e "${YELLOW}需要安装以下依赖:${NC}"
        printf '%s\n' "${missing_deps[@]}"
        
        read -p "是否现在安装这些依赖? [Y/n] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
            if [ -f /etc/debian_version ]; then
                apt-get update
                apt-get install -y "${missing_deps[@]}"
            elif [ -f /etc/redhat-release ]; then
                yum install -y epel-release
                yum install -y "${missing_deps[@]}"
            else
                echo -e "${RED}不支持的系统类型${NC}"
                return 1
            fi
        else
            echo -e "${RED}缺少必要的依赖，无法继续${NC}"
            return 1
        fi
    fi
    return 0
}

# 增强的日志系统
log_message() {
    local level=$1
    local message=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local log_entry="[$timestamp] $level: $message"
    
    # 确保日志目录存在
    [ ! -d "$LOG_DIR" ] && mkdir -p "$LOG_DIR"

    # 写入主日志文件
    echo -e "$log_entry" >> "$LOG_FILE"
    
    # 错误日志单独记录
    if [ "$level" == "ERROR" ]; then
        echo -e "$log_entry" >> "$ERROR_LOG"
    fi

    # 终端输出
    case "$level" in
        "ERROR")   echo -e "${RED}$message${NC}" ;;
        "WARNING") echo -e "${YELLOW}$message${NC}" ;;
        "SUCCESS") echo -e "${GREEN}$message${NC}" ;;
        "INFO")    echo -e "${BLUE}$message${NC}" ;;
        *)         echo -e "$message" ;;
    esac

    # 日志轮转检查
    check_log_rotation
}

# 日志轮转
check_log_rotation() {
    local max_size=$((50*1024*1024)) # 50MB
    
    for log_file in "$LOG_FILE" "$ERROR_LOG"; do
        if [ -f "$log_file" ]; then
            local size=$(stat -f%z "$log_file" 2>/dev/null || stat -c%s "$log_file" 2>/dev/null)
            if [ "$size" -gt "$max_size" ]; then
                local timestamp=$(date +%Y%m%d-%H%M%S)
                mv "$log_file" "${log_file}.${timestamp}"
                gzip "${log_file}.${timestamp}"
                touch "$log_file"
                chmod 644 "$log_file"
            fi
        fi
    done
}

# 系统资源检查
check_system_resources() {
    # 检查内存
    local total_mem=$(free -m | awk '/^Mem:/{print $2}')
    local free_mem=$(free -m | awk '/^Mem:/{print $4}')
    local min_required_mem=512 # 最小需要 512MB 可用内存

    if [ "$free_mem" -lt "$min_required_mem" ]; then
        log_message "WARNING" "可用内存不足: ${free_mem}MB (建议至少 ${min_required_mem}MB)"
        return 1
    fi

    # 检查磁盘空间
    local free_space=$(df -m "$CONFIG_ROOT" | awk 'NR==2 {print $4}')
    local min_required_space=1024 # 最小需要 1GB 可用空间

    if [ "$free_space" -lt "$min_required_space" ]; then
        log_message "WARNING" "磁盘空间不足: ${free_space}MB (建议至少 ${min_required_space}MB)"
        return 1
    fi

    return 0
}

# 状态管理
save_status() {
    local status_type=$1
    local status_value=$2
    
    # 确保配置目录存在
    [ ! -d "$CONFIG_DIR" ] && mkdir -p "$CONFIG_DIR"
    
    # 创建或更新状态文件
    if [ ! -f "$STATUS_FILE" ]; then
        echo "{}" > "$STATUS_FILE"
    fi
    
    # 更新状态
    local tmp_file=$(mktemp)
    jq --arg type "$status_type" --arg value "$status_value" \
       '.[$type] = $value' "$STATUS_FILE" > "$tmp_file" && mv "$tmp_file" "$STATUS_FILE"
}

# 使用说明
show_usage() {
    echo -e "${YELLOW}=== 代理服务器配置流程 ===${NC}"
    echo -e "推荐配置顺序："
    echo -e "1. 环境配置 - 安装必要的软件包和服务"
    echo -e "2. BBR加速 - 优化网络性能"
    echo -e "3. IPv6管理 - 配置IPv6地址（可选）"
    echo -e "4. 带宽控制 - 设置流量限制"
    echo -e "5. SOCKS5设置 - 配置代理服务"
    echo -e "6. IP策略 - 设置进出流量规则"
    echo -e "7. 连通性测试 - 验证代理是否正常工作"
    echo -e "${GREEN}提示：首次使用请按照顺序依次配置${NC}"
    echo -e "${RED}注意：清除规则(选项9)会重置所有设置${NC}\n"
}

################################################################################

################################################################################
#                          安装和环境配置模块 - 完整版                           #
################################################################################

# Xray 版本控制
XRAY_VERSION="latest"
XRAY_INSTALL_DIR="/usr/local/bin"
XRAY_SERVICE_FILE="/etc/systemd/system/xray.service"
XRAY_ACCESS_LOG="/var/log/xray/access.log"
XRAY_ERROR_LOG="/var/log/xray/error.log"

# 软件安装前检查
pre_install_check() {
    log_message "INFO" "执行安装前检查..."
    
    # 检查是否已安装
    if [ -f "$XRAY_SERVICE_FILE" ]; then
        log_message "WARNING" "检测到已存在的 Xray 安装，是否重新安装？[y/N]"
        read -r response
        if [[ ! $response =~ ^[Yy]$ ]]; then
            log_message "INFO" "取消安装"
            return 1
        fi
    fi

    # 检查系统架构
    case $(uname -m) in
        x86_64|amd64)
            ARCH="64"
            ;;
        aarch64|arm64)
            ARCH="arm64-v8a"
            ;;
        *)
            log_message "ERROR" "不支持的系统架构: $(uname -m)"
            return 1
            ;;
    esac

    # 检查必要端口是否被占用
    if netstat -tuln | grep -q ":$DEFAULT_PORT "; then
        log_message "ERROR" "默认端口 $DEFAULT_PORT 已被占用"
        return 1
    fi

    return 0
}

# 增强的软件包安装
install_required_packages() {
    log_message "INFO" "安装必要的软件包..."
    
    local packages=(
        "curl" "wget" "unzip" "iptables" "bc" "jq"
        "ca-certificates" "openssl" "lsof" "netstat-nat"
    )

    # 根据系统类型安装包
    if [ -f /etc/debian_version ]; then
        apt-get update
        for pkg in "${packages[@]}"; do
            if ! dpkg -l | grep -q "^ii  $pkg "; then
                apt-get install -y "$pkg"
                if [ $? -ne 0 ]; then
                    log_message "ERROR" "安装 $pkg 失败"
                    return 1
                fi
            fi
        done
    elif [ -f /etc/redhat-release ]; then
        yum clean all
        yum makecache
        for pkg in "${packages[@]}"; do
            if ! rpm -q "$pkg" >/dev/null 2>&1; then
                yum install -y "$pkg"
                if [ $? -ne 0 ]; then
                    log_message "ERROR" "安装 $pkg 失败"
                    return 1
                fi
            fi
        done
    else
        log_message "ERROR" "不支持的系统类型"
        return 1
    fi

    return 0
}

# 增强的 Xray 安装
install_xray() {
    log_message "INFO" "开始安装 Xray..."

    # 创建必要的目录
    mkdir -p "$XRAY_CONFIG_DIR"
    mkdir -p "$(dirname "$XRAY_ACCESS_LOG")"
    mkdir -p "$(dirname "$XRAY_ERROR_LOG")"

    # 下载最新版本
    local tmp_dir=$(mktemp -d)
    local download_url="https://github.com/XTLS/Xray-core/releases/latest/download/Xray-linux-${ARCH}.zip"
    
    log_message "INFO" "下载 Xray 从 $download_url"
    if ! wget --no-check-certificate -O "${tmp_dir}/xray.zip" "$download_url"; then
        log_message "ERROR" "下载 Xray 失败"
        rm -rf "$tmp_dir"
        return 1
    fi

    # 校验下载文件
    if [ ! -s "${tmp_dir}/xray.zip" ]; then
        log_message "ERROR" "下载的文件为空"
        rm -rf "$tmp_dir"
        return 1
    fi

    # 解压安装
    unzip -o "${tmp_dir}/xray.zip" -d "$tmp_dir"
    if [ ! -f "${tmp_dir}/xray" ]; then
        log_message "ERROR" "解压失败或文件不完整"
        rm -rf "$tmp_dir"
        return 1
    fi

    # 安装文件
    mv "${tmp_dir}/xray" "$XRAY_INSTALL_DIR/"
    chmod +x "$XRAY_INSTALL_DIR/xray"

    # 创建服务文件
    cat > "$XRAY_SERVICE_FILE" << EOF
[Unit]
Description=Xray Service
Documentation=https://github.com/xtls
After=network.target nss-lookup.target

[Service]
User=root
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
NoNewPrivileges=true
ExecStart=$XRAY_INSTALL_DIR/xray run -config $XRAY_CONFIG_DIR/serve.toml
Restart=on-failure
RestartPreventExitStatus=23
LimitNPROC=10000
LimitNOFILE=1000000

[Install]
WantedBy=multi-user.target
EOF

    # 设置日志权限
    touch "$XRAY_ACCESS_LOG"
    touch "$XRAY_ERROR_LOG"
    chmod 644 "$XRAY_ACCESS_LOG"
    chmod 644 "$XRAY_ERROR_LOG"

    # 清理临时文件
    rm -rf "$tmp_dir"

    # 重新加载服务
    systemctl daemon-reload
    systemctl enable xray
    
    # 验证安装
    if ! "$XRAY_INSTALL_DIR/xray" version >/dev/null 2>&1; then
        log_message "ERROR" "Xray 安装验证失败"
        return 1
    fi

    log_message "SUCCESS" "Xray 安装完成"
    return 0
}

# 防火墙配置
configure_firewall() {
    log_message "INFO" "配置防火墙规则..."

    # 保存当前规则
    iptables-save > "$CONFIG_DIR/iptables.backup"
    ip6tables-save > "$CONFIG_DIR/ip6tables.backup"

    # 清除现有规则
    iptables -F
    iptables -X
    iptables -t nat -F
    iptables -t mangle -F
    ip6tables -F
    ip6tables -X
    ip6tables -t nat -F
    ip6tables -t mangle -F

    # 设置默认策略
    iptables -P INPUT ACCEPT
    iptables -P FORWARD ACCEPT
    iptables -P OUTPUT ACCEPT
    ip6tables -P INPUT ACCEPT
    ip6tables -P FORWARD ACCEPT
    ip6tables -P OUTPUT ACCEPT

    # 允许已建立的连接
    iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
    ip6tables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

    # 允许本地回环
    iptables -A INPUT -i lo -j ACCEPT
    ip6tables -A INPUT -i lo -j ACCEPT

    # 保存规则
    if [ -f /etc/debian_version ]; then
        netfilter-persistent save
    elif [ -f /etc/redhat-release ]; then
        service iptables save
        service ip6tables save
    fi

    log_message "SUCCESS" "防火墙规则配置完成"
    return 0
}

################################################################################

################################################################################
#                             IPv6管理模块 - 完整版                              #
################################################################################

# IPv6配置参数
IPV6_CONFIG_FILE="/etc/network/interfaces.d/60-ipv6-addresses"
IPV6_TEMP_FILE="/tmp/ipv6_temp"
MAX_IPV6_ATTEMPTS=10
IPV6_VALID_LIFETIME=86400  # 24小时
IPV6_PREFERRED_LIFETIME=3600  # 1小时

# IPv6基础工具函数
validate_ipv6_address() {
    local address=$1
    # 检查基本格式
    if ! echo "$address" | grep -qP '^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$'; then
        return 1
    fi
    return 0
}

generate_random_hex() {
    local length=$1
    local result=""
    for ((i=0; i<length; i+=2)); do
        result+=$(printf "%02x" $((RANDOM % 256)))
    done
    echo "$result"
}

get_main_interface() {
    local interfaces=($(ip -o link show | awk -F': ' '$2 != "lo" {print $2}'))
    local main_interface=""
    
    # 首先尝试找到默认路由接口
    main_interface=$(ip route | grep default | awk '{print $5}' | head -n1)
    
    if [ -z "$main_interface" ]; then
        # 如果没有默认路由，选择第一个非lo接口
        if [ ${#interfaces[@]} -gt 0 ]; then
            main_interface=${interfaces[0]}
        fi
    fi

    if [ -z "$main_interface" ]; then
        log_message "ERROR" "无法检测到主网卡"
        return 1
    fi

    # 验证接口状态
    if ! ip link show "$main_interface" | grep -q "UP"; then
        log_message "ERROR" "主网卡 $main_interface 未启用"
        return 1
    fi

    echo "$main_interface"
    return 0
}

get_ipv6_prefix() {
    local interface=$1
    local current_ipv6=""
    local prefix=""
    local attempts=0
    
    while [ $attempts -lt 3 ]; do
        current_ipv6=$(ip -6 addr show dev "$interface" | grep "scope global" | grep -v "temporary" | head -n1 | awk '{print $2}')
        
        if [ -n "$current_ipv6" ]; then
            prefix=$(echo "$current_ipv6" | sed -E 's/:[^:]+:[^:]+:[^:]+:[^:]+$/::/')
            if [ -n "$prefix" ]; then
                echo "$prefix"
                return 0
            fi
        fi
        
        ((attempts++))
        sleep 1
    done

    log_message "ERROR" "无法获取IPv6前缀"
    return 1
}

# IPv6地址管理函数
add_ipv6_addresses() {
    local interface=$1
    local prefix=$2
    local num=$3
    local success_count=0
    local existing_addresses=()
    
    # 创建临时文件
    echo -n "" > "$IPV6_TEMP_FILE"
    
    # 获取现有地址列表
    while read -r addr; do
        existing_addresses+=("$addr")
    done < <(ip -6 addr show dev "$interface" | grep "inet6" | grep -v "fe80" | awk '{print $2}' | cut -d'/' -f1)

    log_message "INFO" "开始添加IPv6地址..."
    log_message "INFO" "目标接口: $interface"
    log_message "INFO" "IPv6前缀: $prefix"
    log_message "INFO" "计划添加数量: $num"

    # 添加新地址
    for ((i=0; i<num; i++)); do
        local attempts=0
        while [ $attempts -lt $MAX_IPV6_ATTEMPTS ]; do
            # 生成随机后缀
            local suffix=$(printf "%04x:%04x:%04x:%04x" \
                $((RANDOM % 65536)) \
                $((RANDOM % 65536)) \
                $((RANDOM % 65536)) \
                $((RANDOM % 65536)))
            
            # 构建完整IPv6地址
            local new_addr="${prefix%::}:${suffix}"
            
            # 检查是否已存在
            local exists=0
            for existing in "${existing_addresses[@]}"; do
                if [ "$existing" == "$new_addr" ]; then
                    exists=1
                    break
                fi
            done
            
            if [ $exists -eq 0 ]; then
                if ip -6 addr add "$new_addr/64" dev "$interface" valid_lft $IPV6_VALID_LIFETIME preferred_lft $IPV6_PREFERRED_LIFETIME; then
                    log_message "SUCCESS" "成功添加IPv6地址: $new_addr"
                    echo "iface $interface inet6 static" >> "$IPV6_TEMP_FILE"
                    echo "    address $new_addr/64" >> "$IPV6_TEMP_FILE"
                    echo "" >> "$IPV6_TEMP_FILE"
                    ((success_count++))
                    existing_addresses+=("$new_addr")
                    break
                else
                    log_message "ERROR" "添加地址失败: $new_addr"
                fi
            fi
            
            ((attempts++))
        done
    done

    # 更新配置文件
    if [ $success_count -gt 0 ]; then
        # 备份原配置
        if [ -f "$IPV6_CONFIG_FILE" ]; then
            cp "$IPV6_CONFIG_FILE" "${IPV6_CONFIG_FILE}.bak"
        fi
        
        # 写入新配置
        mv "$IPV6_TEMP_FILE" "$IPV6_CONFIG_FILE"
        chmod 644 "$IPV6_CONFIG_FILE"
        
        # 确保interfaces文件包含必要的配置
        if [ ! -f "/etc/network/interfaces" ]; then
            echo "auto lo" > /etc/network/interfaces
            echo "iface lo inet loopback" >> /etc/network/interfaces
            echo "" >> /etc/network/interfaces
        fi
        
        if ! grep -q "source /etc/network/interfaces.d/\*" /etc/network/interfaces; then
            echo "source /etc/network/interfaces.d/*" >> /etc/network/interfaces
        fi
        
        log_message "SUCCESS" "成功添加 $success_count 个IPv6地址"
        
        # 验证配置
        if ! ifup --no-act "$interface" >/dev/null 2>&1; then
            log_message "WARNING" "接口配置验证失败，但地址已添加"
        fi
    else
        log_message "ERROR" "未能成功添加任何IPv6地址"
        rm -f "$IPV6_TEMP_FILE"
        return 1
    fi

    return 0
}

delete_all_ipv6() {
    local interface=$1
    local count=0
    
    log_message "INFO" "开始删除所有IPv6地址..."
    
    # 备份配置文件
    if [ -f "$IPV6_CONFIG_FILE" ]; then
        cp "$IPV6_CONFIG_FILE" "${IPV6_CONFIG_FILE}.$(date +%Y%m%d_%H%M%S).bak"
        rm -f "$IPV6_CONFIG_FILE"
        log_message "INFO" "已备份并删除配置文件"
    fi

    # 删除所有非链路本地IPv6地址
    while read -r addr; do
        if ip -6 addr del "$addr" dev "$interface" 2>/dev/null; then
            log_message "SUCCESS" "已删除IPv6地址: $addr"
            ((count++))
        else
            log_message "ERROR" "删除地址失败: $addr"
        fi
    done < <(ip -6 addr show dev "$interface" | grep "inet6" | grep -v "fe80" | awk '{print $2}')

    # 重启网络接口
    ip link set dev "$interface" down
    ip link set dev "$interface" up
    
    log_message "INFO" "已删除 $count 个IPv6地址"
    return 0
}

show_current_ipv6() {
    local interface=$1
    local count=0
    
    log_message "INFO" "当前IPv6地址列表："
    echo -e "\n接口: $interface"
    echo "----------------------------------------"
    
    while read -r line; do
        if [[ $line =~ inet6[[:space:]]([^[:space:]]+) ]]; then
            local addr=${BASH_REMATCH[1]}
            local scope=$(echo "$line" | grep -o "scope [^ ]*" | cut -d' ' -f2)
            local flags=$(echo "$line" | grep -o "\\<[[:alnum:]_]*_lft[^[:space:]]*" | tr '\n' ' ')
            
            echo "地址: $addr"
            echo "范围: $scope"
            if [ -n "$flags" ]; then
                echo "标志: $flags"
            fi
            echo "----------------------------------------"
            ((count++))
        fi
    done < <(ip -6 addr show dev "$interface")
    
    if [ $count -eq 0 ]; then
        log_message "WARNING" "未检测到任何IPv6地址"
        return 1
    fi
    
    log_message "INFO" "共发现 $count 个IPv6地址"
    return 0
}

################################################################################

################################################################################
#                             代理配置模块 - 完整版                              #
################################################################################

# 代理配置参数
XRAY_CONFIG_TEMPLATE="/etc/xray/config_template.toml"
PROXY_STATUS_FILE="/etc/xray/proxy_status.json"
DEFAULT_INBOUND_PORT=10800
MAX_CONCURRENT_CONNECTIONS=500
PROXY_TIMEOUT=300

# 代理配置核心函数
configure_ip_strategy() {
    local strategy=$1
    declare -n port_map=$2
    local config_file="/etc/xray/serve.toml"
    local temp_config="/tmp/xray_temp.toml"
    
    # 备份现有配置
    if [ -f "$config_file" ]; then
        cp "$config_file" "${config_file}.$(date +%Y%m%d_%H%M%S).bak"
    fi

    # 创建基础配置
    cat > "$temp_config" << EOF
log {
    access = "$XRAY_ACCESS_LOG"
    error = "$XRAY_ERROR_LOG"
    loglevel = "warning"
}

EOF

    case $strategy in
        1)  # 同IP进同IP出
            log_message "INFO" "配置同IP进出策略..."
            configure_same_ip_strategy "$temp_config"
            ;;
        2)  # IPv4进随机IPv4出
            log_message "INFO" "配置IPv4随机出策略..."
            configure_random_ipv4_strategy "$temp_config"
            ;;
        3)  # IPv4进随机IPv6出
            log_message "INFO" "配置IPv4进IPv6出策略..."
            configure_ipv4_to_ipv6_strategy "$temp_config"
            ;;
        4)  # IPv4进固定IPv6出
            log_message "INFO" "配置固定IPv6出策略..."
            configure_fixed_ipv6_strategy "$temp_config" "$port_map"
            ;;
        *)
            log_message "ERROR" "无效的策略选择: $strategy"
            rm -f "$temp_config"
            return 1
            ;;
    esac

    # 验证配置
    if ! /usr/local/bin/xray -test -config "$temp_config"; then
        log_message "ERROR" "Xray 配置验证失败"
        rm -f "$temp_config"
        return 1
    }

    # 应用新配置
    mv "$temp_config" "$config_file"
    chmod 644 "$config_file"

    # 重启服务
    systemctl restart xray
    sleep 2

    # 检查服务状态
    if ! systemctl is-active --quiet xray; then
        log_message "ERROR" "Xray 服务启动失败"
        systemctl status xray
        return 1
    }

    # 保存策略状态
    save_proxy_status "$strategy"
    
    log_message "SUCCESS" "代理策略配置完成"
    return 0
}

# 同IP进出策略配置
configure_same_ip_strategy() {
    local config_file=$1
    
    for ipv4 in "${ipv4_addrs[@]}"; do
        cat << EOF >> "$config_file"
[[inbounds]]
listen = "$ipv4"
port = $socks_port
protocol = "socks"
tag = "in_$ipv4"
[inbounds.settings]
auth = "password"
udp = true
[[inbounds.settings.accounts]]
user = "$socks_user"
pass = "$socks_pass"

[[outbounds]]
protocol = "freedom"
tag = "out_$ipv4"
[outbounds.settings]
domainStrategy = "UseIPv4"
sendThrough = "$ipv4"

[[routing.rules]]
type = "field"
inboundTag = ["in_$ipv4"]
outboundTag = "out_$ipv4"

EOF
    done
}

# IPv4随机出策略配置
configure_random_ipv4_strategy() {
    local config_file=$1
    
    # 配置入站
    for ipv4 in "${ipv4_addrs[@]}"; do
        cat << EOF >> "$config_file"
[[inbounds]]
listen = "$ipv4"
port = $socks_port
protocol = "socks"
tag = "in_$ipv4"
[inbounds.settings]
auth = "password"
udp = true
[[inbounds.settings.accounts]]
user = "$socks_user"
pass = "$socks_pass"

EOF
    done

    # 创建IP选择脚本
    create_ip_selection_script "ipv4"

    # 配置出站
    local next_ip=$(/etc/xray/track/select_next_ip.sh)
    cat << EOF >> "$config_file"
[[outbounds]]
protocol = "freedom"
tag = "out"
[outbounds.settings]
domainStrategy = "UseIPv4"
sendThrough = "$next_ip"

[[routing.rules]]
type = "field"
network = ["tcp", "udp"]
outboundTag = "out"

EOF
}

# IPv4进IPv6出策略配置
configure_ipv4_to_ipv6_strategy() {
    local config_file=$1
    
    # 配置入站
    for ipv4 in "${ipv4_addrs[@]}"; do
        cat << EOF >> "$config_file"
[[inbounds]]
listen = "$ipv4"
port = $socks_port
protocol = "socks"
tag = "in_$ipv4"
[inbounds.settings]
auth = "password"
udp = true
[[inbounds.settings.accounts]]
user = "$socks_user"
pass = "$socks_pass"

EOF
    done

    # 创建IPv6选择脚本
    create_ip_selection_script "ipv6"

    # 配置出站
    local next_ipv6=$(/etc/xray/track/select_next_ipv6.sh)
    cat << EOF >> "$config_file"
[[outbounds]]
protocol = "freedom"
tag = "out"
[outbounds.settings]
domainStrategy = "UseIPv6"
sendThrough = "$next_ipv6"

[[routing.rules]]
type = "field"
network = ["tcp", "udp"]
outboundTag = "out"

EOF
}

# 固定IPv6出策略配置
configure_fixed_ipv6_strategy() {
    local config_file=$1
    declare -n port_ipv6_map=$2

    for port in "${!port_ipv6_map[@]}"; do
        local ipv6=${port_ipv6_map[$port]}
        
        # 配置出站
        cat << EOF >> "$config_file"
[[outbounds]]
protocol = "freedom"
tag = "out_${port}"
[outbounds.settings]
domainStrategy = "UseIPv6"
sendThrough = "$ipv6"

[[routing.rules]]
type = "field"
inboundTag = ["in_${port}"]
outboundTag = "out_${port}"

EOF

        # 为每个端口配置入站
        for ipv4 in "${ipv4_addrs[@]}"; do
            cat << EOF >> "$config_file"
[[inbounds]]
listen = "$ipv4"
port = $port
protocol = "socks"
tag = "in_${port}"
[inbounds.settings]
auth = "password"
udp = true
[[inbounds.settings.accounts]]
user = "$socks_user"
pass = "$socks_pass"

EOF
        done
    done
}

# 保存代理状态
save_proxy_status() {
    local strategy=$1
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    cat > "$PROXY_STATUS_FILE" << EOF
{
    "strategy": $strategy,
    "last_updated": "$timestamp",
    "socks_port": $socks_port,
    "active_connections": $(netstat -an | grep ":$socks_port" | wc -l),
    "ipv4_addresses": [
        $(printf '"%s",' "${ipv4_addrs[@]}" | sed 's/,$//')
    ],
    "ipv6_addresses": [
        $(printf '"%s",' "${ipv6_addrs[@]}" | sed 's/,$//')
    ]
}
EOF
}

# 创建IP选择脚本
create_ip_selection_script() {
    local ip_version=$1
    local script_dir="/etc/xray/track"
    local script_file=""
    
    mkdir -p "$script_dir"
    
    if [ "$ip_version" == "ipv4" ]; then
        script_file="$script_dir/select_next_ip.sh"
        create_ipv4_selection_script "$script_file"
    else
        script_file="$script_dir/select_next_ipv6.sh"
        create_ipv6_selection_script "$script_file"
    fi
    
    chmod +x "$script_file"
}

# 创建IPv4选择脚本
create_ipv4_selection_script() {
    local script_file=$1
    
    cat > "$script_file" << 'EOF'
#!/bin/bash
TRACK_DIR="/etc/xray/track"
IPV4_USED="$TRACK_DIR/ipv4_used.txt"

all_ipv4=($(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | grep -v '^127\.'))

if [ ! -s "$IPV4_USED" ]; then
    touch "$IPV4_USED"
fi

used_ips=($(cat "$IPV4_USED"))

if [ ${#used_ips[@]} -ge ${#all_ipv4[@]} ]; then
    echo -n "" > "$IPV4_USED"
    used_ips=()
fi

for ip in "${all_ipv4[@]}"; do
    if [[ ! " ${used_ips[*]} " =~ " ${ip} " ]]; then
        echo "$ip" >> "$IPV4_USED"
        echo "$ip"
        exit 0
    fi
done

echo "${all_ipv4[0]}"
EOF
}

# 创建IPv6选择脚本
create_ipv6_selection_script() {
    local script_file=$1
    
    cat > "$script_file" << 'EOF'
#!/bin/bash
TRACK_DIR="/etc/xray/track"
IPV6_USED="$TRACK_DIR/ipv6_used.txt"

all_ipv6=($(ip -6 addr show | grep "inet6" | grep -v "fe80" | grep -v "::1" | awk '{print $2}' | cut -d'/' -f1))

if [ ! -s "$IPV6_USED" ]; then
    touch "$IPV6_USED"
fi

used_ips=($(cat "$IPV6_USED"))

if [ ${#used_ips[@]} -ge ${#all_ipv6[@]} ]; then
    echo -n "" > "$IPV6_USED"
    used_ips=()
fi

for ip in "${all_ipv6[@]}"; do
    if [[ ! " ${used_ips[*]} " =~ " ${ip} " ]]; then
        echo "$ip" >> "$IPV6_USED"
        echo "$ip"
        exit 0
    fi
done

echo "${all_ipv6[0]}"
EOF
}

################################################################################

################################################################################
#                             系统优化模块 - 完整版                              #
################################################################################

# 系统优化参数
SYSCTL_CONF="/etc/sysctl.conf"
LIMITS_CONF="/etc/security/limits.conf"
TC_SCRIPT="/usr/local/bin/tc_control.sh"
BBR_STATUS_FILE="/etc/proxy_manager/bbr_status"

# 系统参数优化
optimize_system_parameters() {
    log_message "INFO" "开始系统参数优化..."
    
    # 备份原始配置
    cp "$SYSCTL_CONF" "${SYSCTL_CONF}.bak.$(date +%Y%m%d)"
    
    # 网络参数优化
    cat >> "$SYSCTL_CONF" << EOF
# 网络性能优化
net.core.rmem_max = 67108864
net.core.wmem_max = 67108864
net.core.rmem_default = 65536
net.core.wmem_default = 65536
net.core.netdev_max_backlog = 250000
net.core.somaxconn = 4096

# TCP优化
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_fin_timeout = 30
net.ipv4.tcp_keepalive_time = 1200
net.ipv4.tcp_max_syn_backlog = 8192
net.ipv4.tcp_max_tw_buckets = 5000
net.ipv4.tcp_fastopen = 3
net.ipv4.tcp_mem = 25600 51200 102400
net.ipv4.tcp_rmem = 4096 87380 67108864
net.ipv4.tcp_wmem = 4096 65536 67108864
net.ipv4.tcp_mtu_probing = 1
net.ipv4.ip_local_port_range = 1024 65535

# IPv6优化
net.ipv6.conf.all.forwarding = 1
net.ipv6.conf.default.forwarding = 1
net.ipv6.conf.all.accept_ra = 2
net.ipv6.conf.default.accept_ra = 2

# 内存优化
vm.swappiness = 10
vm.dirty_ratio = 60
vm.dirty_background_ratio = 2
EOF

    # 应用系统参数
    sysctl -p
    
    # 优化系统限制
    cat >> "$LIMITS_CONF" << EOF
# 系统资源限制优化
* soft nofile 1000000
* hard nofile 1000000
* soft nproc 65535
* hard nproc 65535
EOF

    # 重新加载系统限制
    ulimit -n 1000000
    
    log_message "SUCCESS" "系统参数优化完成"
    return 0
}

# BBR配置和管理
setup_bbr() {
    log_message "INFO" "开始配置BBR..."
    
    # 检查内核版本
    local kernel_version=$(uname -r | cut -d. -f1,2)
    if (( $(echo "$kernel_version < 4.9" | bc -l) )); then
        log_message "ERROR" "当前内核版本 ($kernel_version) 不支持BBR，需要4.9或更高版本"
        return 1
    }

    # 检查是否已启用BBR
    if sysctl net.ipv4.tcp_congestion_control | grep -q "bbr"; then
        log_message "INFO" "BBR已经启用"
        return 0
    }

    # 配置BBR
    cat >> "$SYSCTL_CONF" << EOF
# BBR配置
net.core.default_qdisc = fq
net.ipv4.tcp_congestion_control = bbr
EOF

    # 应用配置
    sysctl -p

    # 验证BBR状态
    if sysctl net.ipv4.tcp_congestion_control | grep -q "bbr"; then
        echo "enabled" > "$BBR_STATUS_FILE"
        log_message "SUCCESS" "BBR配置成功"
        return 0
    else
        log_message "ERROR" "BBR配置失败"
        return 1
    fi
}

# 带宽控制
setup_bandwidth_control() {
    local total_bandwidth=$1
    local interface=$2
    
    log_message "INFO" "配置带宽控制: $total_bandwidth 在接口 $interface"

    # 创建带宽控制脚本
    cat > "$TC_SCRIPT" << EOF
#!/bin/bash

# 清除现有规则
tc qdisc del dev $interface root 2>/dev/null

# 创建HTB规则
tc qdisc add dev $interface root handle 1: htb default 10
tc class add dev $interface parent 1: classid 1:1 htb rate ${total_bandwidth}mbit ceil ${total_bandwidth}mbit
tc class add dev $interface parent 1:1 classid 1:10 htb rate \$((${total_bandwidth}/2))mbit ceil ${total_bandwidth}mbit

# 添加公平队列
tc qdisc add dev $interface parent 1:10 handle 10: fq_codel

# 添加过滤规则
tc filter add dev $interface parent 1: protocol ip prio 1 u32 match ip dst 0.0.0.0/0 flowid 1:10
EOF

    chmod +x "$TC_SCRIPT"

    # 创建系统服务
    cat > "/etc/systemd/system/bandwidth-control.service" << EOF
[Unit]
Description=Bandwidth Control Service
After=network.target

[Service]
Type=oneshot
ExecStart=$TC_SCRIPT
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF

    # 启用服务
    systemctl daemon-reload
    systemctl enable bandwidth-control
    systemctl start bandwidth-control

    # 验证带宽控制
    if ! tc qdisc show dev "$interface" | grep -q "htb"; then
        log_message "ERROR" "带宽控制配置失败"
        return 1
    fi

    log_message "SUCCESS" "带宽控制配置完成"
    return 0
}

# 连接数优化
optimize_connections() {
    log_message "INFO" "优化系统连接数设置..."

    # 修改系统最大连接数
    cat > "/etc/security/limits.d/proxy-limits.conf" << EOF
* soft nproc 65535
* hard nproc 65535
* soft nofile 1000000
* hard nofile 1000000
EOF

    # 优化系统连接跟踪
    cat >> "$SYSCTL_CONF" << EOF
# 连接跟踪优化
net.netfilter.nf_conntrack_max = 1000000
net.netfilter.nf_conntrack_tcp_timeout_established = 7200
net.netfilter.nf_conntrack_tcp_timeout_time_wait = 30
EOF

    # 加载连接跟踪模块
    modprobe nf_conntrack
    
    # 应用更改
    sysctl -p
    
    log_message "SUCCESS" "连接数优化完成"
    return 0
}

# 网络性能监控
monitor_network_performance() {
    local interface=$1
    local duration=${2:-60} # 默认监控60秒
    
    log_message "INFO" "开始网络性能监控 ($duration 秒)..."

    # 创建监控目录
    local monitor_dir="/etc/proxy_manager/monitor"
    mkdir -p "$monitor_dir"

    # 开始监控
    sar -n DEV 1 "$duration" > "$monitor_dir/network_stats.log" &
    local monitor_pid=$!

    # 收集TCP统计信息
    netstat -s > "$monitor_dir/tcp_stats_before.log"
    
    # 等待监控完成
    wait $monitor_pid

    # 再次收集TCP统计信息
    netstat -s > "$monitor_dir/tcp_stats_after.log"

    # 分析结果
    log_message "INFO" "网络性能监控完成，结果保存在 $monitor_dir"
    
    # 显示简要统计
    local rx_before=$(grep "$interface" "$monitor_dir/network_stats.log" | head -n 1 | awk '{print $5}')
    local rx_after=$(grep "$interface" "$monitor_dir/network_stats.log" | tail -n 1 | awk '{print $5}')
    local tx_before=$(grep "$interface" "$monitor_dir/network_stats.log" | head -n 1 | awk '{print $6}')
    local tx_after=$(grep "$interface" "$monitor_dir/network_stats.log" | tail -n 1 | awk '{print $6}')

    echo "接收速率: $(echo "scale=2; ($rx_after - $rx_before) / $duration" | bc) KB/s"
    echo "发送速率: $(echo "scale=2; ($tx_after - $tx_before) / $duration" | bc) KB/s"

    return 0
}

################################################################################

################################################################################
#                             主程序模块 - 完整版                               #
################################################################################

# 全局变量
VERSION="1.0.0"
SCRIPT_PATH=$(readlink -f "$0")
SCRIPT_DIR=$(dirname "$SCRIPT_PATH")
CONFIG_VERSION="1"

# 初始化函数
init_environment() {
    log_message "INFO" "初始化环境..."
    
    # 检查root权限
    if [ "$EUID" -ne 0 ]; then 
        log_message "ERROR" "请使用root权限运行此脚本"
        exit 1
    fi

    # 创建必要的目录结构
    local dirs=(
        "$CONFIG_ROOT"
        "$CONFIG_DIR"
        "$LOG_DIR"
        "$TRACK_DIR"
        "$XRAY_CONFIG_DIR"
    )

    for dir in "${dirs[@]}"; do
        if ! mkdir -p "$dir"; then
            log_message "ERROR" "无法创建目录: $dir"
            exit 1
        fi
    done

    # 初始化配置文件
    if [ ! -f "$CONFIG_DIR/config.json" ]; then
        create_default_config
    fi

    # 检查系统依赖
    check_dependencies

    # 检查系统资源
    check_system_resources

    return 0
}

# 创建默认配置
create_default_config() {
    cat > "$CONFIG_DIR/config.json" << EOF
{
    "version": "$CONFIG_VERSION",
    "last_update": "$(date '+%Y-%m-%d %H:%M:%S')",
    "settings": {
        "default_port": $DEFAULT_INBOUND_PORT,
        "max_connections": $MAX_CONCURRENT_CONNECTIONS,
        "timeout": $PROXY_TIMEOUT
    },
    "network": {
        "bbr_enabled": false,
        "bandwidth_limit": null,
        "ipv6_enabled": false
    }
}
EOF
}

# 主菜单函数
show_main_menu() {
    while true; do
        clear
        echo -e "${YELLOW}=== 代理服务器管理工具 v${VERSION} ===${NC}"
        echo -e "1. 系统管理"
        echo -e "2. 网络配置"
        echo -e "3. 代理设置"
        echo -e "4. 监控与维护"
        echo -e "5. 系统优化"
        echo -e "6. 查看状态"
        echo -e "7. 备份与恢复"
        echo -e "8. 更新系统"
        echo -e "9. 卸载系统"
        echo -e "0. 退出"
        
        read -p "请选择功能 [0-9]: " main_choice
        
        case $main_choice in
            1) system_management_menu ;;
            2) network_configuration_menu ;;
            3) proxy_settings_menu ;;
            4) monitoring_maintenance_menu ;;
            5) system_optimization_menu ;;
            6) show_system_status ;;
            7) backup_restore_menu ;;
            8) update_system ;;
            9) uninstall_system ;;
            0) confirm_exit ;;
            *) log_message "ERROR" "无效的选择" ;;
        esac
    done
}

# 系统管理菜单
system_management_menu() {
    while true; do
        clear
        echo -e "${YELLOW}=== 系统管理 ===${NC}"
        echo "1. 安装必要组件"
        echo "2. 管理系统服务"
        echo "3. 配置系统参数"
        echo "4. 管理防火墙规则"
        echo "5. 查看系统日志"
        echo "0. 返回主菜单"
        
        read -p "请选择操作 [0-5]: " choice
        
        case $choice in
            1) setup_environment ;;
            2) manage_services ;;
            3) configure_system_params ;;
            4) manage_firewall ;;
            5) view_system_logs ;;
            0) break ;;
            *) log_message "ERROR" "无效的选择" ;;
        esac
        
        press_enter_to_continue
    done
}

# 网络配置菜单
network_configuration_menu() {
    while true; do
        clear
        echo -e "${YELLOW}=== 网络配置 ===${NC}"
        echo "1. IPv6地址管理"
        echo "2. 带宽控制设置"
        echo "3. 网络接口配置"
        echo "4. DNS设置"
        echo "5. 路由表管理"
        echo "0. 返回主菜单"
        
        read -p "请选择操作 [0-5]: " choice
        
        case $choice in
            1) ipv6_manager_menu ;;
            2) bandwidth_control_menu ;;
            3) interface_configuration ;;
            4) dns_settings ;;
            5) route_management ;;
            0) break ;;
            *) log_message "ERROR" "无效的选择" ;;
        esac
        
        press_enter_to_continue
    done
}

# 代理设置菜单
proxy_settings_menu() {
    while true; do
        clear
        echo -e "${YELLOW}=== 代理设置 ===${NC}"
        echo "1. 设置SOCKS5凭证"
        echo "2. 配置IP策略"
        echo "3. 管理代理端口"
        echo "4. 查看代理状态"
        echo "5. 测试代理连接"
        echo "0. 返回主菜单"
        
        read -p "请选择操作 [0-5]: " choice
        
        case $choice in
            1) set_socks5_credentials ;;
            2) set_ip_strategy ;;
            3) manage_proxy_ports ;;
            4) show_proxy_status ;;
            5) test_proxy_connectivity ;;
            0) break ;;
            *) log_message "ERROR" "无效的选择" ;;
        esac
        
        press_enter_to_continue
    done
}

# 监控与维护菜单
monitoring_maintenance_menu() {
    while true; do
        clear
        echo -e "${YELLOW}=== 监控与维护 ===${NC}"
        echo "1. 查看实时流量"
        echo "2. 连接状态监控"
        echo "3. 系统资源监控"
        echo "4. 查看错误日志"
        echo "5. 性能测试"
        echo "0. 返回主菜单"
        
        read -p "请选择操作 [0-5]: " choice
        
        case $choice in
            1) monitor_traffic ;;
            2) monitor_connections ;;
            3) monitor_resources ;;
            4) view_error_logs ;;
            5) run_performance_test ;;
            0) break ;;
            *) log_message "ERROR" "无效的选择" ;;
        esac
        
        press_enter_to_continue
    done
}

# 系统优化菜单
system_optimization_menu() {
    while true; do
        clear
        echo -e "${YELLOW}=== 系统优化 ===${NC}"
        echo "1. 启用BBR加速"
        echo "2. 优化系统参数"
        echo "3. 优化网络设置"
        echo "4. 配置资源限制"
        echo "5. 性能调优"
        echo "0. 返回主菜单"
        
        read -p "请选择操作 [0-5]: " choice
        
        case $choice in
            1) setup_bbr ;;
            2) optimize_system_parameters ;;
            3) optimize_network ;;
            4) configure_resource_limits ;;
            5) performance_tuning ;;
            0) break ;;
            *) log_message "ERROR" "无效的选择" ;;
        esac
        
        press_enter_to_continue
    done
}

# 备份与恢复菜单
backup_restore_menu() {
    while true; do
        clear
        echo -e "${YELLOW}=== 备份与恢复 ===${NC}"
        echo "1. 创建完整备份"
        echo "2. 恢复系统备份"
        echo "3. 导出配置文件"
        echo "4. 导入配置文件"
        echo "5. 管理备份文件"
        echo "0. 返回主菜单"
        
        read -p "请选择操作 [0-5]: " choice
        
        case $choice in
            1) create_backup ;;
            2) restore_backup ;;
            3) export_config ;;
            4) import_config ;;
            5) manage_backups ;;
            0) break ;;
            *) log_message "ERROR" "无效的选择" ;;
        esac
        
        press_enter_to_continue
    done
}

# 工具函数
press_enter_to_continue() {
    echo
    read -p "按回车键继续..."
}

confirm_exit() {
    read -p "确定要退出吗？[y/N] " response
    if [[ $response =~ ^[Yy]$ ]]; then
        log_message "INFO" "正在退出系统..."
        exit 0
    fi
}

# 状态显示函数
show_system_status() {
    clear
    echo -e "${YELLOW}=== 系统状态 ===${NC}"
    
    # 显示系统信息
    echo -e "\n${BLUE}系统信息:${NC}"
    echo "操作系统: $(cat /etc/os-release | grep PRETTY_NAME | cut -d'"' -f2)"
    echo "内核版本: $(uname -r)"
    echo "运行时间: $(uptime -p)"
    
    # 显示网络信息
    echo -e "\n${BLUE}网络状态:${NC}"
    echo "IPv4地址: $(hostname -I | cut -d' ' -f1)"
    echo "IPv6地址数量: $(ip -6 addr | grep "inet6" | grep -v "fe80" | wc -l)"
    
    # 显示代理状态
    echo -e "\n${BLUE}代理状态:${NC}"
    if systemctl is-active --quiet xray; then
        echo -e "Xray状态: ${GREEN}运行中${NC}"
    else
        echo -e "Xray状态: ${RED}未运行${NC}"
    fi
    
    # 显示资源使用
    echo -e "\n${BLUE}资源使用:${NC}"
    echo "CPU使用率: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}')%"
    echo "内存使用: $(free -h | awk '/^Mem:/ {print $3 "/" $2}')"
    echo "磁盘使用: $(df -h / | awk 'NR==2 {print $5}')"
    
    # 显示连接信息
    echo -e "\n${BLUE}连接统计:${NC}"
    echo "当前连接数: $(netstat -an | grep ESTABLISHED | wc -l)"
    echo "TCP连接数: $(netstat -nt | grep ESTABLISHED | wc -l)"
    echo "UDP连接数: $(netstat -nu | grep ESTABLISHED | wc -l)"
    
    press_enter_to_continue
}

# 主程序入口
main() {
    # 初始化环境
    init_environment
    
    # 显示欢迎信息
    clear
    echo -e "${YELLOW}欢迎使用代理服务器管理工具 v${VERSION}${NC}"
    echo -e "初始化完成，正在启动主程序...\n"
    sleep 1
    
    # 显示主菜单
    show_main_menu
}

# 启动主程序
main

################################################################################
