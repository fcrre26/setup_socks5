#!/bin/bash

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 默认值设置
DEFAULT_START_PORT=20000
DEFAULT_SOCKS_USERNAME="1234"
DEFAULT_SOCKS_PASSWORD="1234"

# 使用说明
show_usage() {
    echo -e "${YELLOW}=== 代理服务器配置流程 ===${NC}"
    echo -e "推荐配置顺序："
    echo -e "1. 环境配置 - 安装必要的软件包和服务"
    echo -e "2. BBR加速 - 优化网络性能"
    echo -e "3. IPv6管理 - 配置IPv6地址（可选）"
    echo -e "4. 带宽控制 - 设置流量限制"
    echo -e "5. SOCKS5设置 - 配置代理服务"
    echo -e "6. IP策略 - 设置进出流量规则"
    echo -e "7. 连通性测试 - 验证代理是否正常工作"
    echo -e "${GREEN}提示：首次使用请按照顺序依次配置${NC}"
    echo -e "${RED}注意：清除规则(选项9)会重置所有设置${NC}\n"
}

# 系统检测模块
detect_system() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        case "$ID" in
            "ubuntu"|"debian")
                service_manager="systemctl"
                ;;
            "centos")
                if (( $(echo "$VERSION_ID >= 7" | bc -l) )); then
                    service_manager="systemctl"
                else
                    service_manager="service"
                fi
                ;;
            *)
                echo -e "${RED}不支持的系统${NC}"
                return 1
                ;;
        esac
    else
        echo -e "${RED}无法识别的系统${NC}"
        return 1
    fi
}

# 软件安装模块
check_and_install_unzip() {
    if ! command -v unzip &> /dev/null; then
        echo "未安装unzip，正在安装..."
        if [ "$ID" == "centos" ]; then
            yum install unzip -y
        else
            apt-get update && apt-get install unzip -y
        fi
    fi
    return 0
}

check_and_install_iptables() {
    if ! command -v iptables &> /dev/null; then
        echo "未安装iptables，正在安装..."
        if [ "$ID" == "centos" ]; then
            yum install iptables-services -y
            systemctl enable iptables
        else
            apt-get update && apt-get install iptables-persistent -y
        fi
    fi
    return 0
}


# 环境配置模块
setup_environment() {
    echo "开始环境配置..."

    # 更新系统包
    if [ "$ID" == "centos" ]; then
        yum update -y
        yum install -y wget curl bc iptables-services
    else
        apt-get update
        apt-get install -y wget curl bc iptables-persistent
    fi

    # 安装必要组件
    check_and_install_unzip
    check_and_install_iptables

    # 安装 Xray
    if ! [ -x "$(command -v xray)" ]; then
        install_xray
        if [ $? -ne 0 ]; then
            echo -e "${RED}Xray 安装失败${NC}"
            return 1
        fi
    else
        echo "Xray 已安装"
    fi

    # 创建必要的目录
    mkdir -p /etc/xray

    echo -e "${GREEN}环境配置完成${NC}"
    return 0
}


# 系统检查模块
check_ipv6() {
    if ! sysctl -a 2>/dev/null | grep -q "net.ipv6.conf.all.disable_ipv6 = 0"; then
        echo "启用IPv6支持..."
        sysctl -w net.ipv6.conf.all.disable_ipv6=0
        sysctl -w net.ipv6.conf.default.disable_ipv6=0
        echo "net.ipv6.conf.all.disable_ipv6 = 0" >> /etc/sysctl.conf
        echo "net.ipv6.conf.default.disable_ipv6 = 0" >> /etc/sysctl.conf
        sysctl -p
    fi
    return 0
}

# Xray安装模块
install_xray() {
    echo "安装 Xray..."
    apt-get install unzip -y || yum install unzip -y
    wget https://github.com/XTLS/Xray-core/releases/download/v1.8.3/Xray-linux-64.zip
    unzip Xray-linux-64.zip
    mv xray /usr/local/bin/xray
    chmod +x /usr/local/bin/xray

    # 创建服务文件
    cat <<EOF >/etc/systemd/system/xray.service
[Unit]
Description=Xray Service
After=network.target

[Service]
ExecStart=/usr/local/bin/xray -c /etc/xray/config.toml
Restart=on-failure
User=nobody
RestartSec=3

[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload
    systemctl enable xray.service
    
    # 验证安装
    if ! [ -x "$(command -v xray)" ]; then
        echo "Xray 安装失败"
        return 1
    fi
    
    echo "Xray 安装完成."
    return 0
}

# SOCKS5配置模块
set_socks5_credentials() {
    # 检查 Xray 是否已安装
    if ! [ -x "$(command -v xray)" ]; then
        echo "Xray 未安装，请先运行环境配置（选项1）"
        return 1
    fi

    read -p "请输入SOCKS5起始端口 (默认: $DEFAULT_START_PORT): " socks_port
    socks_port=${socks_port:-$DEFAULT_START_PORT}
    read -p "请输入用户名 (默认: $DEFAULT_SOCKS_USERNAME): " socks_user
    socks_user=${socks_user:-$DEFAULT_SOCKS_USERNAME}
    read -p "请输入密码 (默认: $DEFAULT_SOCKS_PASSWORD): " socks_pass
    socks_pass=${socks_pass:-$DEFAULT_SOCKS_PASSWORD}

    # 验证输入
    if ! [[ "$socks_port" =~ ^[0-9]+$ ]] || [ "$socks_port" -lt 1 ] || [ "$socks_port" -gt 65535 ]; then
        echo -e "${RED}无效的端口号${NC}"
        return 1
    fi

    if [ -z "$socks_user" ] || [ -z "$socks_pass" ]; then
        echo -e "${RED}用户名和密码不能为空${NC}"
        return 1
    fi

    # 保存配置
    mkdir -p /etc/xray
    echo "SOCKS_PORT=$socks_port" > /etc/xray/credentials
    echo "SOCKS_USER=$socks_user" >> /etc/xray/credentials
    echo "SOCKS_PASS=$socks_pass" >> /etc/xray/credentials

    # 设置IP策略
    set_ip_strategy

    echo "SOCKS5端口、用户名和密码设置完成。"
    return 0
}

# IP策略配置模块
set_ip_strategy() {
    echo "配置IP进出策略..."

    # 获取IPv4和IPv6地址
    ipv4_addrs=($(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | grep -v '^127\.'))
    ipv6_addrs=($(ip -6 addr show | grep "inet6" | grep -v "fe80" | grep -v "::1" | awk '{print $2}' | cut -d'/' -f1))

    # 检查地址可用性
    if [ ${#ipv4_addrs[@]} -eq 0 ]; then
        echo -e "${RED}未检测到有效的IPv4地址${NC}"
        return 1
    fi

    if [ ${#ipv6_addrs[@]} -eq 0 ]; then
        echo -e "${YELLOW}未检测到IPv6地址，某些策略可能无法使用${NC}"
    fi

    # 如果没有之前设置的信息，使用默认值
    socks_port=${socks_port:-$DEFAULT_START_PORT}
    socks_user=${socks_user:-$DEFAULT_SOCKS_USERNAME}
    socks_pass=${socks_pass:-$DEFAULT_SOCKS_PASSWORD}

    echo "当前IPv4地址: ${ipv4_addrs[@]}"
    echo "当前IPv6地址: ${ipv6_addrs[@]}"

    echo "请选择IP进出策略："
    echo "1. 同IP进同IP出（默认）"
    echo "2. IPv4进随机IPv4出（不重复直到耗尽）"
    echo "3. IPv4进随机IPv6出（不重复直到耗尽）"
    echo "4. IPv4进，不同端口对应固定IPv6出（自动分配）"
    read -p "请输入选项 [1-4]: " strategy

    # 创建配置目录和清空配置文件
    mkdir -p /etc/xray
    echo -n "" > /etc/xray/config.toml

    # 根据不同策略生成配置内容
    case $strategy in
        1)  # 同IP进同IP出
            echo -e "${YELLOW}策略1: 同IP进同IP出${NC}"
            config_content=""
            for ipv4 in "${ipv4_addrs[@]}"; do
                config_content+="[[inbounds]]\n"
                config_content+="port = $socks_port\n"
                config_content+="protocol = \"socks\"\n"
                config_content+="tag = \"inbound_${ipv4}\"\n"
                config_content+="[inbounds.settings]\n"
                config_content+="auth = \"password\"\n"
                config_content+="udp = true\n"
                config_content+="ip = \"${ipv4}\"\n"
                config_content+="[[inbounds.settings.accounts]]\n"
                config_content+="user = \"$socks_user\"\n"
                config_content+="pass = \"$socks_pass\"\n\n"

                config_content+="[[outbounds]]\n"
                config_content+="protocol = \"freedom\"\n"
                config_content+="tag = \"outbound_${ipv4}\"\n"
                config_content+="sendThrough = \"${ipv4}\"\n\n"

                config_content+="[[routing.rules]]\n"
                config_content+="type = \"field\"\n"
                config_content+="inboundTag = [\"inbound_${ipv4}\"]\n"
                config_content+="outboundTag = \"outbound_${ipv4}\"\n\n"

                socks_port=$((socks_port + 1))
            done
            ;;

        2)  # IPv4进随机IPv4出
            echo -e "${YELLOW}策略2: IPv4进随机IPv4出${NC}"
            config_content=""
            
            # 创建负载均衡组
            config_content+="[[outbounds]]\n"
            config_content+="protocol = \"freedom\"\n"
            config_content+="tag = \"ipv4_random\"\n"
            config_content+="settings = { domainStrategy = \"UseIPv4\" }\n\n"

            # 为每个IPv4创建出站
            for ipv4 in "${ipv4_addrs[@]}"; do
                config_content+="[[outbounds]]\n"
                config_content+="protocol = \"freedom\"\n"
                config_content+="tag = \"outbound_${ipv4}\"\n"
                config_content+="sendThrough = \"${ipv4}\"\n\n"
            done

            # 创建入站
            config_content+="[[inbounds]]\n"
            config_content+="port = $socks_port\n"
            config_content+="protocol = \"socks\"\n"
            config_content+="tag = \"inbound_ipv4_random\"\n"
            config_content+="[inbounds.settings]\n"
            config_content+="auth = \"password\"\n"
            config_content+="udp = true\n"
            config_content+="[[inbounds.settings.accounts]]\n"
            config_content+="user = \"$socks_user\"\n"
            config_content+="pass = \"$socks_pass\"\n\n"

            # 创建负载均衡规则
            config_content+="[[routing.balancers]]\n"
            config_content+="tag = \"ipv4_balancer\"\n"
            config_content+="strategy = \"random\"\n"
            config_content+="selector = ["
            for ipv4 in "${ipv4_addrs[@]}"; do
                config_content+="\"outbound_${ipv4}\","
            done
            config_content="${config_content%,}]\n\n"

            # 创建路由规则
            config_content+="[[routing.rules]]\n"
            config_content+="type = \"field\"\n"
            config_content+="inboundTag = [\"inbound_ipv4_random\"]\n"
            config_content+="balancerTag = \"ipv4_balancer\"\n\n"
            ;;

        3)  # IPv4进随机IPv6出
            echo -e "${YELLOW}策略3: IPv4进随机IPv6出${NC}"
            if [ ${#ipv6_addrs[@]} -eq 0 ]; then
                echo -e "${RED}没有可用的IPv6地址${NC}"
                return 1
            fi

            config_content=""
            
            # 创建负载均衡组
            config_content+="[[outbounds]]\n"
            config_content+="protocol = \"freedom\"\n"
            config_content+="tag = \"ipv6_random\"\n"
            config_content+="settings = { domainStrategy = \"UseIPv6\" }\n\n"

            # 为每个IPv6创建出站
            for ipv6 in "${ipv6_addrs[@]}"; do
                config_content+="[[outbounds]]\n"
                config_content+="protocol = \"freedom\"\n"
                config_content+="tag = \"outbound_${ipv6//:/}\"\n"
                config_content+="[outbounds.settings]\n"
                config_content+="domainStrategy = \"UseIPv6\"\n"
                config_content+="[outbounds.streamSettings]\n"
                config_content+="[outbounds.streamSettings.sockopt]\n"
                config_content+="bindAddress = \"$ipv6\"\n\n"
            done
            # 创建入站
            config_content+="[[inbounds]]\n"
            config_content+="port = $socks_port\n"
            config_content+="protocol = \"socks\"\n"
            config_content+="tag = \"inbound_ipv6_random\"\n"
            config_content+="[inbounds.settings]\n"
            config_content+="auth = \"password\"\n"
            config_content+="udp = true\n"
            config_content+="[[inbounds.settings.accounts]]\n"
            config_content+="user = \"$socks_user\"\n"
            config_content+="pass = \"$socks_pass\"\n\n"

            # 创建负载均衡规则
            config_content+="[[routing.balancers]]\n"
            config_content+="tag = \"ipv6_balancer\"\n"
            config_content+="strategy = \"random\"\n"
            config_content+="selector = ["
            for ipv6 in "${ipv6_addrs[@]}"; do
                config_content+="\"outbound_${ipv6//:/}\","
            done
            config_content="${config_content%,}]\n\n"

            # 创建路由规则
            config_content+="[[routing.rules]]\n"
            config_content+="type = \"field\"\n"
            config_content+="inboundTag = [\"inbound_ipv6_random\"]\n"
            config_content+="balancerTag = \"ipv6_balancer\"\n\n"
            ;;

        4)  # IPv4进不同端口对应固定IPv6出
            echo -e "${YELLOW}策略4: IPv4进不同端口对应固定IPv6出${NC}"
            local ipv6_count=${#ipv6_addrs[@]}
            
            if [ $ipv6_count -eq 0 ]; then
                echo -e "${RED}没有可用的IPv6地址${NC}"
                return 1
            fi

            read -p "请输入要配置的端口数量 (最大 $ipv6_count): " port_count
            if ! [[ "$port_count" =~ ^[0-9]+$ ]] || [ "$port_count" -lt 1 ] || [ "$port_count" -gt "$ipv6_count" ]; then
                echo -e "${RED}无效的端口数量${NC}"
                return 1
            fi

            config_content=""
            for ((i=0; i<port_count; i++)); do
                current_port=$((socks_port + i))
                current_ipv6=${ipv6_addrs[$i]}
                
                config_content+="[[inbounds]]\n"
                config_content+="port = $current_port\n"
                config_content+="protocol = \"socks\"\n"
                config_content+="tag = \"inbound_port_${current_port}\"\n"
                config_content+="[inbounds.settings]\n"
                config_content+="auth = \"password\"\n"
                config_content+="udp = true\n"
                config_content+="[[inbounds.settings.accounts]]\n"
                config_content+="user = \"$socks_user\"\n"
                config_content+="pass = \"$socks_pass\"\n\n"

                config_content+="[[outbounds]]\n"
                config_content+="protocol = \"freedom\"\n"
                config_content+="tag = \"outbound_port_${current_port}\"\n"
                config_content+="[outbounds.settings]\n"
                config_content+="domainStrategy = \"UseIPv6\"\n"
                config_content+="[outbounds.streamSettings]\n"
                config_content+="[outbounds.streamSettings.sockopt]\n"
                config_content+="bindAddress = \"$current_ipv6\"\n\n"

                config_content+="[[routing.rules]]\n"
                config_content+="type = \"field\"\n"
                config_content+="inboundTag = [\"inbound_port_${current_port}\"]\n"
                config_content+="outboundTag = \"outbound_port_${current_port}\"\n\n"
            done
            ;;
        *)
            echo -e "${RED}无效的策略选择${NC}"
            return 1
            ;;
    esac

    # 写入配置文件
    echo -e "$config_content" > /etc/xray/config.toml

    # 重启服务
    systemctl restart xray.service
    sleep 2

    if ! systemctl is-active --quiet xray.service; then
        echo -e "${RED}Xray 服务启动失败${NC}"
        systemctl status xray.service
        return 1
    fi

    # 生成代理列表
    echo -e "\n# 策略配置信息" > /root/proxy_list.txt
    case $strategy in
        1)
            echo -e "# 策略：同IP进同IP出\n" >> /root/proxy_list.txt
            for ipv4 in "${ipv4_addrs[@]}"; do
                echo "$ipv4:$socks_port:$socks_user:$socks_pass # 出口: $ipv4" >> /root/proxy_list.txt
                socks_port=$((socks_port + 1))
            done
            ;;
        2)
            echo -e "# 策略：IPv4进随机IPv4出\n" >> /root/proxy_list.txt
            echo -e "# 可能的出口IP: ${ipv4_addrs[*]}\n" >> /root/proxy_list.txt
            echo "$ipv4_addrs:$socks_port:$socks_user:$socks_pass" >> /root/proxy_list.txt
            ;;
        3)
            echo -e "# 策略：IPv4进随机IPv6出\n" >> /root/proxy_list.txt
            echo -e "# 可能的出口IP: ${ipv6_addrs[*]}\n" >> /root/proxy_list.txt
            echo "$ipv4_addrs:$socks_port:$socks_user:$socks_pass" >> /root/proxy_list.txt
            ;;
        4)
            echo -e "# 策略：IPv4进不同端口对应固定IPv6出\n" >> /root/proxy_list.txt
            for ((i=0; i<port_count; i++)); do
                current_port=$((socks_port + i))
                current_ipv6=${ipv6_addrs[$i]}
                echo -e "\n# 端口 $current_port 对应的IPv6出口: $current_ipv6" >> /root/proxy_list.txt
                for ipv4 in "${ipv4_addrs[@]}"; do
                    echo "$ipv4:$current_port:$socks_user:$socks_pass # 出口: $current_ipv6" >> /root/proxy_list.txt
                done
            done
            ;;
    esac

    echo -e "${GREEN}IP策略设置完成并成功启动服务${NC}"
    return 0
}

# 工具函数
get_active_interfaces() {
    interfaces=$(ip -o link show | awk -F': ' '$2 != "lo" {print $2}')
    echo "检测到的活动网络接口: $interfaces"
    return 0
}

get_active_ip_count() {
    active_ip_count=$(hostname -I | wc -w)
    echo "当前活动的IP数量: $active_ip_count"
    return 0
}

# 带宽控制和BBR相关函数
setup_bandwidth_control() {
    get_active_interfaces
    get_active_ip_count

    read -p "请输入VPS的总带宽（例如50M）: " total_bandwidth

    if [[ ! $total_bandwidth =~ ^[0-9]+M$ ]]; then
        echo -e "${RED}ERROR: 输入格式错误，请输入类似'50M'的格式。${NC}"
        return 1
    fi

    if [ "$active_ip_count" -eq 0 ]; then
        echo "INFO: 没有活动的IP，跳过带宽设置。"
        return 0
    fi

    local rate=$(echo "${total_bandwidth%M} / $active_ip_count" | bc)Mbit

    echo "INFO: 设置带宽控制..."
    for interface in $interfaces; do
        tc qdisc del dev $interface root 2>/dev/null
        tc qdisc add dev $interface root handle 1: htb default 30
        tc class add dev $interface parent 1: classid 1:1 htb rate $total_bandwidth

        for ip in $(hostname -I); do
            tc class add dev $interface parent 1:1 classid 1:10 htb rate ${rate} ceil ${rate}
            tc filter add dev $interface protocol ip parent 1:0 prio 1 u32 match ip dst $ip flowid 1:10
        done
    done

    echo "INFO: 带宽控制设置完成。"
    return 0
}

enable_bbr() {
    echo "启用BBR..."

    if ! sysctl net.ipv4.tcp_available_congestion_control | grep -q "bbr"; then
        echo -e "${RED}当前内核不支持BBR，请升级内核。${NC}"
        return 1
    fi

    echo "net.core.default_qdisc=fq" | tee -a /etc/sysctl.conf
    echo "net.ipv4.tcp_congestion_control=bbr" | tee -a /etc/sysctl.conf

    sysctl -p

    if sysctl net.ipv4.tcp_congestion_control | grep -q "bbr"; then
        echo -e "${GREEN}BBR已成功启用。${NC}"
    else
        echo -e "${RED}BBR启用失败，请检查配置。${NC}"
    fi
    return 0
}

# 测试代理连通性
test_proxy_connectivity() {
    echo "测试代理连通性..."

    if [ ! -f /root/proxy_list.txt ]; then
        echo -e "${RED}/root/proxy_list.txt 文件不存在。${NC}"
        return 1
    fi

    while IFS= read -r line; do
        if [[ $line =~ ^(.+):([0-9]+):(.+):(.+)$ ]]; then
            ip="${BASH_REMATCH[1]}"
            port="${BASH_REMATCH[2]}"
            user="${BASH_REMATCH[3]}"
            pass="${BASH_REMATCH[4]}"

            echo "正在测试 $ip:$port..."

            if [[ $ip == *:* ]]; then
                ip="[$ip]"
            fi

            if curl -s --proxy socks5h://$user:$pass@$ip:$port http://httpbin.org/ip -o /dev/null; then
                echo -e "${GREEN}$ip:$port 代理连接成功${NC}"
            else
                echo -e "${RED}$ip:$port 代理连接失败${NC}"
            fi
        else
            echo -e "${RED}行格式不正确: $line${NC}"
        fi
    done < /root/proxy_list.txt

    echo "代理连通性测试完成。"
    return 0
}

# 清理函数
clear_proxy_rules() {
    echo "清除所有代理规则..."
    $service_manager stop xray
    $service_manager disable xray
    rm -f /etc/xray/serve.toml
    rm -f /etc/systemd/system/xray.service
    iptables -F
    iptables -X
    iptables -t nat -F
    iptables -t mangle -F
    ip6tables -F
    ip6tables -X
    ip6tables -t nat -F
    ip6tables -t mangle -F
    iptables-save
    ip6tables-save
    rm -f /root/proxy_list.txt
    echo "已清除所有代理规则，回到未安装SOCKS5代理的状态。"
    return 0
}

# IPv6相关函数
generate_random_hex() {
    local length=$1
    head -c $((length/2)) /dev/urandom | hexdump -ve '1/1 "%.2x"'
}

get_main_interface() {
    MAIN_INTERFACE=$(ip route | grep default | awk '{print $5}' | head -n1)
    if [ -z "$MAIN_INTERFACE" ]; then
        echo -e "${RED}错误: 无法检测到主网卡${NC}"
        return 1
    fi
    echo $MAIN_INTERFACE
}

# 修改 add_ipv6_addresses 函数中的这部分代码
add_ipv6_addresses() {
    local interface=$1
    local prefix=$2
    local count=$3
    local added=0

    echo "正在添加IPv6地址..."
    
    # 检查是否有权限修改网络配置
    if ! ip -6 addr show dev "$interface" > /dev/null 2>&1; then
        echo -e "${RED}错误：没有足够的权限操作网络接口${NC}"
        return 1
    fi

    # 检查IPv6是否启用
    if [ ! -f "/proc/sys/net/ipv6/conf/$interface/disable_ipv6" ] || [ "$(cat /proc/sys/net/ipv6/conf/$interface/disable_ipv6)" != "0" ]; then
        echo -e "${RED}错误：IPv6未在接口 $interface 上启用${NC}"
        return 1
    fi

    # 确保系统允许添加多个IPv6地址
    sysctl -w net.ipv6.conf.all.accept_ra=2 > /dev/null 2>&1
    sysctl -w net.ipv6.conf."$interface".accept_ra=2 > /dev/null 2>&1
    
    for ((i=1; i<=count; i++)); do
        # 生成更短的后缀（使用16个字符而不是32个）
        local suffix=$(generate_random_hex 16)
        local ipv6_addr="${prefix}${suffix}"
        
        echo "尝试添加IPv6地址: ${ipv6_addr}"
        
        # 使用ip命令添加地址，并增加重试机制
        for retry in {1..3}; do
            if ip -6 addr add "${ipv6_addr}/64" dev "$interface" 2>/dev/null; then
                echo -e "${GREEN}成功添加IPv6地址: ${ipv6_addr}${NC}"
                ((added++))
                break
            else
                echo -e "${YELLOW}第 $retry 次尝试添加地址失败，等待重试...${NC}"
                sleep 1
            fi
        done
    done

    if [ "$added" -eq 0 ]; then
        echo -e "${RED}警告：没有成功添加任何IPv6地址${NC}"
        echo "请检查以下几点："
        echo "1. 是否有root权限"
        echo "2. 网络接口是否正确配置"
        echo "3. IPv6是否正确启用"
        echo "4. 系统是否允许添加额外的IPv6地址"
        return 1
    fi

    echo -e "${GREEN}成功添加 $added 个IPv6地址${NC}"
    return 0
}

show_current_ipv6() {
    local interface=$1
    echo -e "${YELLOW}当前IPv6地址列表：${NC}"
    ip -6 addr show dev $interface scope global
    return 0
}

# IPv6管理菜单
ipv6_manager_menu() {
    while true; do
        echo -e "\n${YELLOW}IPv6地址管理工具${NC}"
        echo "1. 添加随机IPv6地址"
        echo "2. 删除所有IPv6地址"
        echo "3. 显示当前IPv6地址"
        echo "4. 测试IPv6连通性"
        echo "0. 返回主菜单"

        read -p "请选择操作 [0-4]: " ipv6_option

        case $ipv6_option in
            1)
                INTERFACE=$(get_main_interface)
                if [ $? -ne 0 ]; then
                    echo -e "${RED}获取网络接口失败${NC}"
                    continue
                fi

                # 先显示当前IPv6信息
                echo -e "${YELLOW}当前IPv6配置：${NC}"
                ip -6 addr show dev "$INTERFACE"

                # 获取IPv6前缀
                PREFIX=$(ip -6 addr show dev "$INTERFACE" | grep "scope global" | grep -v "temporary" | head -n1 | awk '{print $2}' | cut -d'/' -f1 | sed -E 's/:[^:]+:[^:]+:[^:]+:[^:]+$/::/')

                if [ -z "$PREFIX" ]; then
                    echo -e "${RED}无法获取IPv6前缀${NC}"
                    continue
                fi

                echo -e "${GREEN}使用IPv6前缀: $PREFIX${NC}"

                read -p "请输入要添加的IPv6地址数量: " num_addresses
                if [[ ! "$num_addresses" =~ ^[0-9]+$ ]]; then
                    echo -e "${RED}请输入有效的数字${NC}"
                    continue
                fi

                # 确保函数在子shell中执行
                (
                    add_ipv6_addresses "$INTERFACE" "$PREFIX" "$num_addresses"
                )
                ;;
            2)
                INTERFACE=$(get_main_interface)
                if [ $? -eq 0 ]; then
                    delete_all_ipv6 "$INTERFACE"
                fi
                ;;
            3)
                INTERFACE=$(get_main_interface)
                if [ $? -eq 0 ]; then
                    show_current_ipv6 "$INTERFACE"
                fi
                ;;
            4)
                test_proxy_connectivity
                ;;
            0)
                return 0
                ;;
            *)
                echo -e "${RED}无效的选择${NC}"
                ;;
        esac

        echo -e "\n按回车键继续..."
        read
    done
}

delete_all_ipv6() {
    local interface=$1
    echo "删除所有IPv6地址..."
    
    if [ -z "$interface" ]; then
        echo -e "${RED}错误：未指定网络接口${NC}"
        return 1
    fi

    # 保存原始IPv6地址（第一个全局地址）
    local original_ipv6=$(ip -6 addr show dev "$interface" scope global | grep -v temporary | head -n1 | awk '{print $2}')
    
    # 删除所有IPv6地址
    ip -6 addr flush dev "$interface" scope global
    
    # 如果有原始地址，恢复它
    if [ -n "$original_ipv6" ]; then
        echo "恢复原始IPv6地址: $original_ipv6"
        ip -6 addr add "$original_ipv6" dev "$interface"
    fi
    
    echo -e "${GREEN}已删除所有额外的IPv6地址${NC}"
    return 0
}



# 主菜单
show_menu() {
    echo -e "\n${YELLOW}=== 代理服务器管理工具 ===${NC}"
    echo "1. 环境配置（安装必要组件）"
    echo "2. 启用BBR加速"
    echo "3. IPv6地址管理"
    echo "4. 设置带宽控制"
    echo "5. SOCKS5代理设置"
    echo "6. 设置IP进出策略"
    echo "7. 测试代理连通性"
    echo "8. 显示代理列表"
    echo "9. 清除所有代理规则"
    echo "10. 退出"

    read -p "请输入选项 [1-10]: " option
    case $option in
        1) 
            setup_environment
            ;;
        2) 
            enable_bbr 
            ;;
        3) 
            ipv6_manager_menu 
            ;;
        4) 
            setup_bandwidth_control 
            ;;
        5) 
            if ! [ -x "$(command -v xray)" ]; then
                echo -e "${RED}请先运行环境配置（选项1）安装 Xray${NC}"
                return 1
            fi
            set_socks5_credentials 
            ;;
        6) 
            if ! [ -x "$(command -v xray)" ]; then
                echo -e "${RED}请先运行环境配置（选项1）安装 Xray${NC}"
                return 1
            fi
            set_ip_strategy 
            ;;
        7) 
            test_proxy_connectivity 
            ;;
        8) 
            if [ -f /root/proxy_list.txt ]; then
                echo -e "\n${YELLOW}当前代理配置：${NC}"
                cat /root/proxy_list.txt
            else
                echo -e "${RED}/root/proxy_list.txt 文件不存在${NC}"
            fi
            ;;
        9) 
            echo -e "${YELLOW}正在清除所有代理规则...${NC}"
            systemctl stop xray
            rm -f /etc/xray/config.toml
            rm -f /root/proxy_list.txt
            echo -e "${GREEN}所有代理规则已清除${NC}"
            ;;
        10) 
            echo -e "${GREEN}退出脚本${NC}"
            exit 0 
            ;;
        *) 
            echo -e "${RED}无效选项，请输入1-10之间的数字${NC}" 
            ;;
    esac

    # 暂停以便查看输出
    echo -e "\n按回车键继续..."
    read
}

# 主程序
main() {
    if [ "$EUID" -ne 0 ]; then 
        echo -e "${RED}请使用root权限运行此脚本${NC}"
        exit 1
    fi

    detect_system
    if [ $? -ne 0 ]; then
        echo -e "${RED}系统检测失败，请检查您的操作系统是否受支持。${NC}"
        exit 1
    fi

    check_and_install_iptables
    check_ipv6

    show_usage

    while true; do
        show_menu
        sleep 1
    done
}

# 运行主程序
main
