#!/bin/bash

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 默认配置
DEFAULT_START_PORT=20000                         #默认起始端口
DEFAULT_SOCKS_USERNAME="1234"                   #默认socks账号
DEFAULT_SOCKS_PASSWORD="1234"               #默认socks密码
DEFAULT_WS_PATH="/ws"                           #默认ws路径
DEFAULT_UUID=$(cat /proc/sys/kernel/random/uuid) #默认随机UUID

# 获取IP地址
IP_ADDRESSES=($(hostname -I))

# 使用说明
show_usage() {
    echo -e "${YELLOW}=== 代理服务器配置流程 ===${NC}"
    echo -e "推荐配置顺序："
    echo -e "1. 环境配置 - 安装必要的软件包和服务"
    echo -e "2. BBR加速 - 优化网络性能"
    echo -e "3. IPv6管理 - 配置IPv6地址（可选）"
    echo -e "4. 带宽控制 - 设置流量限制"
    echo -e "5. SOCKS5设置 - 配置代理服务"
    echo -e "6. IP策略 - 设置进出流量规则"
    echo -e "7. 连通性测试 - 验证代理是否正常工作"
    echo -e "${GREEN}提示：首次使用请按照顺序依次配置${NC}"
    echo -e "${RED}注意：清除规则(选项9)会重置所有设置${NC}\n"
}

# 系统检测模块
detect_system() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        case "$ID" in
            "ubuntu"|"debian")
                service_manager="systemctl"
                ;;
            "centos")
                if (( $(echo "$VERSION_ID >= 7" | bc -l) )); then
                    service_manager="systemctl"
                else
                    service_manager="service"
                fi
                ;;
            *)
                echo -e "${RED}不支持的系统${NC}"
                return 1
                ;;
        esac
    else
        echo -e "${RED}无法识别的系统${NC}"
        return 1
    fi
}

# 软件安装模块
check_and_install_unzip() {
    if ! command -v unzip &> /dev/null; then
        echo "未安装unzip，正在安装..."
        if [ "$ID" == "centos" ]; then
            yum install unzip -y
        else
            apt-get update && apt-get install unzip -y
        fi
    fi
    return 0
}

check_and_install_iptables() {
    if ! command -v iptables &> /dev/null; then
        echo "未安装iptables，正在安装..."
        if [ "$ID" == "centos" ]; then
            yum install iptables-services -y
            systemctl enable iptables
        else
            apt-get update && apt-get install iptables-persistent -y
        fi
    fi
    return 0
}

# 系统检查模块
check_ipv6() {
    if ! sysctl -a 2>/dev/null | grep -q "net.ipv6.conf.all.disable_ipv6 = 0"; then
        echo "启用IPv6支持..."
        sysctl -w net.ipv6.conf.all.disable_ipv6=0
        sysctl -w net.ipv6.conf.default.disable_ipv6=0
        echo "net.ipv6.conf.all.disable_ipv6 = 0" >> /etc/sysctl.conf
        echo "net.ipv6.conf.default.disable_ipv6 = 0" >> /etc/sysctl.conf
        sysctl -p
    fi
    return 0
}

# Xray安装模块
install_xray() {
    echo "安装 Xray..."
    apt-get install unzip -y || yum install unzip -y
    wget https://github.com/XTLS/Xray-core/releases/download/v1.8.3/Xray-linux-64.zip
    unzip Xray-linux-64.zip
    mv xray /usr/local/bin/xrayL
    chmod +x /usr/local/bin/xrayL
    cat <<EOF >/etc/systemd/system/xrayL.service
[Unit]
Description=XrayL Service
After=network.target

[Service]
ExecStart=/usr/local/bin/xrayL -c /etc/xrayL/config.toml
Restart=on-failure
User=nobody
RestartSec=3

[Install]
WantedBy=multi-user.target
EOF
    systemctl daemon-reload
    systemctl enable xrayL.service
    systemctl start xrayL.service
    echo "Xray 安装完成."
}

# Xray配置函数
config_xray() {
    config_type=$1
    mkdir -p /etc/xrayL
    if [ "$config_type" != "socks" ] && [ "$config_type" != "vmess" ]; then
        echo "类型错误！仅支持socks和vmess."
        exit 1
    fi

    read -p "起始端口 (默认 $DEFAULT_START_PORT): " START_PORT
    START_PORT=${START_PORT:-$DEFAULT_START_PORT}
    if [ "$config_type" == "socks" ]; then
        read -p "SOCKS 账号 (默认 $DEFAULT_SOCKS_USERNAME): " SOCKS_USERNAME
        SOCKS_USERNAME=${SOCKS_USERNAME:-$DEFAULT_SOCKS_USERNAME}

        read -p "SOCKS 密码 (默认 $DEFAULT_SOCKS_PASSWORD): " SOCKS_PASSWORD
        SOCKS_PASSWORD=${SOCKS_PASSWORD:-$DEFAULT_SOCKS_PASSWORD}
    elif [ "$config_type" == "vmess" ]; then
        read -p "UUID (默认随机): " UUID
        UUID=${UUID:-$DEFAULT_UUID}
        read -p "WebSocket 路径 (默认 $DEFAULT_WS_PATH): " WS_PATH
        WS_PATH=${WS_PATH:-$DEFAULT_WS_PATH}
    fi

    config_content=""
    for ((i = 0; i < ${#IP_ADDRESSES[@]}; i++)); do
        config_content+="[[inbounds]]\n"
        config_content+="port = $((START_PORT + i))\n"
        config_content+="protocol = \"$config_type\"\n"
        config_content+="tag = \"tag_$((i + 1))\"\n"
        config_content+="[inbounds.settings]\n"
        if [ "$config_type" == "socks" ]; then
            config_content+="auth = \"password\"\n"
            config_content+="udp = true\n"
            config_content+="ip = \"${IP_ADDRESSES[i]}\"\n"
            config_content+="[[inbounds.settings.accounts]]\n"
            config_content+="user = \"$SOCKS_USERNAME\"\n"
            config_content+="pass = \"$SOCKS_PASSWORD\"\n"
        elif [ "$config_type" == "vmess" ]; then
            config_content+="[[inbounds.settings.clients]]\n"
            config_content+="id = \"$UUID\"\n"
            config_content+="[inbounds.streamSettings]\n"
            config_content+="network = \"ws\"\n"
            config_content+="[inbounds.streamSettings.wsSettings]\n"
            config_content+="path = \"$WS_PATH\"\n\n"
        fi
        config_content+="[[outbounds]]\n"
        config_content+="sendThrough = \"${IP_ADDRESSES[i]}\"\n"
        config_content+="protocol = \"freedom\"\n"
        config_content+="tag = \"tag_$((i + 1))\"\n\n"
        config_content+="[[routing.rules]]\n"
        config_content+="type = \"field\"\n"
        config_content+="inboundTag = \"tag_$((i + 1))\"\n"
        config_content+="outboundTag = \"tag_$((i + 1))\"\n\n\n"
    done
    echo -e "$config_content" >/etc/xrayL/config.toml
    systemctl restart xrayL.service
    systemctl --no-pager status xrayL.service
    echo ""
    echo "生成 $config_type 配置完成"
    echo "起始端口:$START_PORT"
    echo "结束端口:$(($START_PORT + $i - 1))"
    if [ "$config_type" == "socks" ]; then
        echo "socks账号:$SOCKS_USERNAME"
        echo "socks密码:$SOCKS_PASSWORD"
    elif [ "$config_type" == "vmess" ]; then
        echo "UUID:$UUID"
        echo "ws路径:$WS_PATH"
    fi
    echo ""
}

# IP策略设置
set_ip_strategy() {
    echo "配置IP进出策略..."
    
    # 如果没有安装 XrayL，先安装
    [ -x "$(command -v xrayL)" ] || install_xray
    
    # 选择代理类型
    read -p "选择生成的节点类型 (socks/vmess): " config_type
    if [ "$config_type" == "vmess" ]; then
        config_xray "vmess"
    elif [ "$config_type" == "socks" ]; then
        config_xray "socks"
    else
        echo "未正确选择类型，使用默认sokcs配置."
        config_xray "socks"
    fi
}

# 代理设置模块
set_socks5_credentials() {
    echo "配置代理服务..."
    [ -x "$(command -v xrayL)" ] || install_xray
    config_xray "socks"
}

# 生成代理列表
generate_proxy_list() {
    local start_port=$1
    local username=$2
    local password=$3
    echo "生成代理列表文件..."
    echo -n "" > /root/proxy_list.txt
    for ((i = 0; i < ${#IP_ADDRESSES[@]}; i++)); do
        echo "${IP_ADDRESSES[i]}:$((start_port + i)):$username:$password" >> /root/proxy_list.txt
    done
    echo "代理列表文件已生成：/root/proxy_list.txt"
    return 0
}

# IPv6相关函数
generate_random_hex() {
    local length=$1
    head -c $((length/2)) /dev/urandom | hexdump -ve '1/1 "%.2x"'
}

get_main_interface() {
    MAIN_INTERFACE=$(ip route | grep default | awk '{print $5}' | head -n1)
    if [ -z "$MAIN_INTERFACE" ]; then
        echo -e "${RED}错误: 无法检测到主网卡${NC}"
        return 1
    fi
    echo $MAIN_INTERFACE
}

get_ipv6_prefix() {
    local interface=$1
    local current_ipv6=$(ip -6 addr show dev $interface | grep "scope global" | grep -v "temporary" | head -n1 | awk '{print $2}')
    
    if [ -z "$current_ipv6" ]; then
        echo -e "${RED}错误: 未检测到IPv6地址${NC}" >&2
        return 1
    fi
    
    local ipv6_addr=$(echo "$current_ipv6" | cut -d'/' -f1)
    local prefix=$(echo "$ipv6_addr" | sed -E 's/:[^:]+:[^:]+:[^:]+:[^:]+$/::/')
    
    if [ -z "$prefix" ]; then
        echo -e "${RED}错误: 无法提取IPv6前缀${NC}" >&2
        return 1
    fi
    
    echo "$prefix"
}

add_ipv6_addresses() {
    local interface=$1
    local prefix=$2
    local num=$3

    echo -e "${YELLOW}准备添加IPv6地址:${NC}"
    echo "使用网络接口: $interface"
    echo "使用IPv6前缀: $prefix"
    echo "计划添加数量: $num"

    declare -A existing_addresses
    while read -r addr; do
        existing_addresses["$addr"]=1
    done < <(ip -6 addr show dev $interface | grep "inet6" | grep -v "fe80" | awk '{print $2}' | cut -d'/' -f1)

    echo -e "\n${YELLOW}当前IPv6地址:${NC}"
    ip -6 addr show dev $interface

    count=0
    attempts=0
    max_attempts=$((num * 3))

    while [ $count -lt $num ] && [ $attempts -lt $max_attempts ]; do
        ((attempts++))
        
        suffix=$(printf "%04x:%04x:%04x:%04x" \
            $((RANDOM % 65536)) \
            $((RANDOM % 65536)) \
            $((RANDOM % 65536)) \
            $((RANDOM % 65536)))
        
        NEW_IPV6="${prefix%::}:${suffix}"
        
        if [ "${existing_addresses[$NEW_IPV6]}" == "1" ]; then
            continue
        fi

        if ip -6 addr add "$NEW_IPV6/64" dev "$interface" 2>/dev/null; then
            echo -e "${GREEN}成功添加IPv6地址: $NEW_IPV6${NC}"
            existing_addresses["$NEW_IPV6"]=1
            ((count++))
            
            mkdir -p /etc/network/interfaces.d
            echo "iface $interface inet6 static" >> /etc/network/interfaces.d/60-ipv6-addresses
            echo "    address $NEW_IPV6/64" >> /etc/network/interfaces.d/60-ipv6-addresses
            echo "" >> /etc/network/interfaces.d/60-ipv6-addresses
        fi
    done

    if [ ! -f "/etc/network/interfaces" ]; then
        echo "auto lo" > /etc/network/interfaces
        echo "iface lo inet loopback" >> /etc/network/interfaces
        echo "" >> /etc/network/interfaces
    fi

    if ! grep -q "source /etc/network/interfaces.d/*" /etc/network/interfaces; then
        echo "source /etc/network/interfaces.d/*" >> /etc/network/interfaces
    fi
}

# 带宽控制和BBR相关函数
setup_bandwidth_control() {
    get_active_interfaces
    get_active_ip_count

    read -p "请输入VPS的总带宽（例如50M）: " total_bandwidth

    if [[ ! $total_bandwidth =~ ^[0-9]+M$ ]]; then
        echo -e "${RED}ERROR: 输入格式错误，请输入类似'50M'的格式。${NC}"
        return 1
    fi

    if [ "$active_ip_count" -eq 0 ]; then
        echo "INFO: 没有活动的IP，跳过带宽设置。"
        return 0
    fi

    local rate=$(echo "${total_bandwidth%M} / $active_ip_count" | bc)Mbit

    echo "INFO: 设置带宽控制..."
    for interface in $interfaces; do
        tc qdisc del dev $interface root 2>/dev/null
        tc qdisc add dev $interface root handle 1: htb default 30
        tc class add dev $interface parent 1: classid 1:1 htb rate $total_bandwidth

        for ip in $(hostname -I); do
            tc class add dev $interface parent 1:1 classid 1:10 htb rate ${rate} ceil ${rate}
            tc filter add dev $interface protocol ip parent 1:0 prio 1 u32 match ip dst $ip flowid 1:10
        done
    done

    echo "INFO: 带宽控制设置完成。"
    return 0
}

enable_bbr() {
    echo "启用BBR..."

    if ! sysctl net.ipv4.tcp_available_congestion_control | grep -q "bbr"; then
        echo -e "${RED}当前内核不支持BBR，请升级内核。${NC}"
        return 1
    fi

    echo "net.core.default_qdisc=fq" | tee -a /etc/sysctl.conf
    echo "net.ipv4.tcp_congestion_control=bbr" | tee -a /etc/sysctl.conf

    sysctl -p

    if sysctl net.ipv4.tcp_congestion_control | grep -q "bbr"; then
        echo -e "${GREEN}BBR已成功启用。${NC}"
    else
        echo -e "${RED}BBR启用失败，请检查配置。${NC}"
    fi
    return 0
}

# 测试代理连通性
test_proxy_connectivity() {
    echo "测试代理连通性..."

    if [ ! -f /root/proxy_list.txt ]; then
        echo -e "${RED}/root/proxy_list.txt 文件不存在。${NC}"
        return 1
    fi

    while IFS= read -r line; do
        if [[ $line =~ ^(.+):([0-9]+):(.+):(.+)$ ]]; then
            ip="${BASH_REMATCH[1]}"
            port="${BASH_REMATCH[2]}"
            user="${BASH_REMATCH[3]}"
            pass="${BASH_REMATCH[4]}"

            echo "正在测试 $ip:$port..."

            if [[ $ip == *:* ]]; then
                ip="[$ip]"
            fi

            if curl -s --proxy socks5h://$user:$pass@$ip:$port http://httpbin.org/ip -o /dev/null; then
                echo -e "${GREEN}$ip:$port 代理连接成功${NC}"
            else
                echo -e "${RED}$ip:$port 代理连接失败${NC}"
            fi
        fi
    done < /root/proxy_list.txt

    echo "代理连通性测试完成。"
    return 0
}

# IPv6管理菜单
ipv6_manager_menu() {
    while true; do
        echo -e "\n${YELLOW}IPv6地址管理工具${NC}"
        echo "1. 添加随机IPv6地址"
        echo "2. 删除所有IPv6地址"
        echo "3. 显示当前IPv6地址"
        echo "4. 测试IPv6连通性"
        echo "0. 返回主菜单"

        read -p "请选择操作 [0-4]: " ipv6_option

        case $ipv6_option in
            1)
                INTERFACE=$(get_main_interface)
                if [ $? -ne 0 ]; then
                    continue
                fi
                PREFIX=$(get_ipv6_prefix $INTERFACE)
                if [ $? -ne 0 ]; then
                    continue
                fi
                read -p "请输入要添加的IPv6地址数量: " num_addresses
                if [[ ! "$num_addresses" =~ ^[0-9]+$ ]]; then
                    echo -e "${RED}请输入有效的数字${NC}"
                    continue
                fi
                add_ipv6_addresses "$INTERFACE" "$PREFIX" "$num_addresses"
                ;;
            2)
                INTERFACE=$(get_main_interface)
                if [ $? -eq 0 ]; then
                    delete_all_ipv6 $INTERFACE
                fi
                ;;
            3)
                INTERFACE=$(get_main_interface)
                if [ $? -eq 0 ]; then
                    show_current_ipv6 $INTERFACE
                fi
                ;;
            4)
                test_proxy_connectivity
                ;;
            0)
                return
                ;;
            *)
                echo -e "${RED}无效的选择${NC}"
                ;;
        esac

        echo -e "\n按回车键继续..."
        read
    done
}

# 清理规则函数
clear_proxy_rules() {
    echo "清除所有代理规则..."
    
    # 停止并禁用 XrayL 服务
    systemctl stop xrayL
    systemctl disable xrayL
    
    # 删除配置文件和服务
    rm -f /etc/xrayL/config.toml
    rm -f /etc/systemd/system/xrayL.service
    rm -f /usr/local/bin/xrayL
    rm -rf /etc/xrayL
    
    # 清除防火墙规则
    iptables -F
    iptables -X
    iptables -t nat -F
    iptables -t mangle -F
    ip6tables -F
    ip6tables -X
    ip6tables -t nat -F
    ip6tables -t mangle -F
    
    # 保存防火墙规则
    iptables-save
    ip6tables-save
    
    # 删除代理列表
    rm -f /root/proxy_list.txt
    
    echo "已清除所有代理规则和配置文件。"
    return 0
}

# 删除所有IPv6地址
delete_all_ipv6() {
    local interface=$1
    
    # 删除配置文件
    CONFIG_FILE="/etc/network/interfaces.d/60-ipv6-addresses"
    if [ -f "$CONFIG_FILE" ]; then
        rm -f "$CONFIG_FILE"
        echo -e "${GREEN}已删除IPv6配置文件${NC}"
    fi
    
    # 删除所有非本地IPv6地址
    for addr in $(ip -6 addr show dev $interface | grep "inet6" | grep -v "fe80" | awk '{print $2}'); do
        ip -6 addr del $addr dev $interface
        echo -e "${YELLOW}已删除IPv6地址: $addr${NC}"
    done
    
    echo -e "${GREEN}所有配置的IPv6地址已删除${NC}"
    return 0
}

# 显示当前IPv6地址
show_current_ipv6() {
    local interface=$1
    echo -e "${YELLOW}当前IPv6地址列表：${NC}"
    
    # 获取所有非本地IPv6地址
    local ipv6_list=$(ip -6 addr show dev $interface | grep "inet6" | grep -v "fe80")
    
    if [ -z "$ipv6_list" ]; then
        echo -e "${RED}未检测到任何IPv6地址${NC}"
        return 1
    fi
    
    # 显示地址列表
    echo "$ipv6_list"
    return 0
}

# 获取活动网络接口
get_active_interfaces() {
    interfaces=$(ip -o link show | awk -F': ' '$2 != "lo" {print $2}')
    echo "检测到的活动网络接口: $interfaces"
    return 0
}

# 获取活动IP数量
get_active_ip_count() {
    active_ip_count=$(hostname -I | wc -w)
    echo "当前活动的IP数量: $active_ip_count"
    return 0
}

# 工具函数：检查端口是否被占用
check_port() {
    local port=$1
    if netstat -tuln | grep -q ":$port "; then
        return 0
    else
        return 1
    fi
}

# 工具函数：检查服务状态
check_service_status() {
    local service_name=$1
    if systemctl is-active --quiet $service_name; then
        echo -e "${GREEN}$service_name 服务运行正常${NC}"
        return 0
    else
        echo -e "${RED}$service_name 服务未运行${NC}"
        return 1
    fi
}

# 环境配置模块
setup_environment() {
    echo "设置防火墙规则..."
    iptables -P INPUT ACCEPT
    iptables -P FORWARD ACCEPT
    iptables -P OUTPUT ACCEPT
    iptables -t nat -F
    iptables -t mangle -F
    iptables -F
    iptables -X
    iptables-save

    # 安装必要的软件包
    check_and_install_unzip
    check_and_install_iptables
    
    # 安装并配置Xray
    install_xray
    
    # 创建必要的目录
    mkdir -p /etc/xrayL/track
    
    echo "环境配置完成。"
    return 0
}

# 代理状态检查
check_proxy_status() {
    echo "检查代理服务状态..."
    
    # 检查XrayL服务状态
    check_service_status "xrayL"
    
    # 检查配置文件
    if [ -f "/etc/xrayL/config.toml" ]; then
        echo -e "${GREEN}配置文件存在${NC}"
    else
        echo -e "${RED}配置文件不存在${NC}"
    fi
    
    # 检查端口状态
    if [ -f "/root/proxy_list.txt" ]; then
        while IFS=: read -r ip port user pass; do
            if check_port "$port"; then
                echo -e "${GREEN}端口 $port 正在监听${NC}"
            else
                echo -e "${RED}端口 $port 未在监听${NC}"
            fi
        done < /root/proxy_list.txt
    fi
    
    return 0
}

# 更新Xray版本
update_xray() {
    echo "正在检查Xray更新..."
    
    # 获取最新版本
    latest_version=$(curl -s https://api.github.com/repos/XTLS/Xray-core/releases/latest | grep "tag_name" | cut -d'"' -f4)
    
    if [ -z "$latest_version" ]; then
        echo -e "${RED}无法获取最新版本信息${NC}"
        return 1
    }
    
    echo "最新版本: $latest_version"
    
    # 下载并安装新版本
    wget --no-check-certificate -O /tmp/xray.zip "https://github.com/XTLS/Xray-core/releases/download/$latest_version/Xray-linux-64.zip"
    
    if [ $? -ne 0 ]; then
        echo -e "${RED}下载失败${NC}"
        return 1
    }
    
    systemctl stop xrayL
    unzip -o /tmp/xray.zip -d /tmp/xray/
    mv /tmp/xray/xray /usr/local/bin/xrayL
    chmod +x /usr/local/bin/xrayL
    rm -rf /tmp/xray/ /tmp/xray.zip
    systemctl start xrayL
    
    echo -e "${GREEN}Xray更新完成${NC}"
    return 0
}

# 备份和恢复配置
backup_config() {
    local backup_dir="/root/proxy_backup"
    local backup_file="$backup_dir/backup_$(date +%Y%m%d_%H%M%S).tar.gz"
    
    mkdir -p "$backup_dir"
    
    # 创建备份
    tar -czf "$backup_file" \
        /etc/xrayL \
        /etc/systemd/system/xrayL.service \
        /root/proxy_list.txt \
        /etc/network/interfaces.d/60-ipv6-addresses \
        2>/dev/null
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}配置已备份到: $backup_file${NC}"
    else
        echo -e "${RED}备份失败${NC}"
        return 1
    fi
    
    # 清理旧备份（保留最近5个）
    ls -t "$backup_dir"/*.tar.gz 2>/dev/null | tail -n +6 | xargs rm -f 2>/dev/null
    
    return 0
}

restore_config() {
    local backup_dir="/root/proxy_backup"
    
    if [ ! -d "$backup_dir" ]; then
        echo -e "${RED}没有找到备份目录${NC}"
        return 1
    }
    
    # 显示可用的备份
    echo "可用的备份文件："
    ls -lt "$backup_dir"/*.tar.gz 2>/dev/null | awk '{print NR")", $9}'
    
    read -p "请选择要恢复的备份编号: " backup_num
    
    local backup_file=$(ls -t "$backup_dir"/*.tar.gz 2>/dev/null | sed -n "${backup_num}p")
    
    if [ ! -f "$backup_file" ]; then
        echo -e "${RED}无效的备份文件${NC}"
        return 1
    }
    
    # 停止服务
    systemctl stop xrayL
    
    # 恢复配置
    tar -xzf "$backup_file" -C /
    
    # 重启服务
    systemctl daemon-reload
    systemctl start xrayL
    
    echo -e "${GREEN}配置已恢复${NC}"
    return 0
}

# 更新主菜单
show_menu() {
    echo -e "\n${YELLOW}=== 代理服务器管理工具 ===${NC}"
    echo "1. 环境配置（安装必要组件）"
    echo "2. 启用BBR加速"
    echo "3. IPv6地址管理"
    echo "4. 设置带宽控制"
    echo "5. SOCKS5代理设置"
    echo "6. 设置IP进出策略"
    echo "7. 测试代理连通性"
    echo "8. 显示代理列表"
    echo "9. 清除所有代理规则"
    echo "10. 检查代理状态"
    echo "11. 更新Xray版本"
    echo "12. 备份配置"
    echo "13. 恢复配置"
    echo "14. 退出"

    read -p "请输入选项 [1-14]: " option
    case $option in
        1) setup_environment ;;
        2) enable_bbr ;;
        3) ipv6_manager_menu ;;
        4) setup_bandwidth_control ;;
        5) set_socks5_credentials ;;
        6) set_ip_strategy ;;
        7) test_proxy_connectivity ;;
        8) 
            if [ -f /root/proxy_list.txt ]; then
                cat /root/proxy_list.txt
            else
                echo -e "${RED}/root/proxy_list.txt 文件不存在。${NC}"
            fi
            ;;
        9) clear_proxy_rules ;;
        10) check_proxy_status ;;
        11) update_xray ;;
        12) backup_config ;;
        13) restore_config ;;
        14) echo "退出脚本。"; exit ;;
        *) echo -e "${RED}无效选项，请输入1-14之间的数字${NC}" ;;
    esac
}


# 主程序
main() {
    # 检查root权限
    if [ "$EUID" -ne 0 ]; then 
        echo -e "${RED}请使用root权限运行此脚本${NC}"
        exit 1
    fi

    # 初始化
    detect_system
    if [ $? -ne 0 ]; then
        echo -e "${RED}系统检测失败，请检查您的操作系统是否受支持。${NC}"
        exit 1
    fi

    check_and_install_iptables
    check_ipv6

    # 显示使用说明
    show_usage

    # 主循环
    while true; do
        show_menu
        sleep 1
    done
}

# 运行主程序
main
