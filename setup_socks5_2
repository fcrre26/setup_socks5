#!/bin/bash

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 默认配置
DEFAULT_START_PORT=20000
DEFAULT_SOCKS_USERNAME="userb"
DEFAULT_SOCKS_PASSWORD="passwordb"
DEFAULT_WS_PATH="/ws"
DEFAULT_UUID=$(cat /proc/sys/kernel/random/uuid)

# 使用说明
show_usage() {
    echo -e "${YELLOW}=== 代理服务器配置流程 ===${NC}"
    echo -e "推荐配置顺序："
    echo -e "1. 环境配置 - 安装必要的软件包和服务"
    echo -e "2. BBR加速 - 优化网络性能"
    echo -e "3. IPv6管理 - 配置IPv6地址（可选）"
    echo -e "4. 带宽控制 - 设置流量限制"
    echo -e "5. 配置代理服务和IP策略"
    echo -e "6. 连通性测试 - 验证代理是否正常工作"
    echo -e "${GREEN}提示：首次使用请按照顺序依次配置${NC}"
    echo -e "${RED}注意：清除规则(选项8)会重置所有设置${NC}\n"
}

# 系统检测模块
detect_system() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        case "$ID" in
            "ubuntu"|"debian")
                service_manager="systemctl"
                ;;
            "centos")
                if (( $(echo "$VERSION_ID >= 7" | bc -l) )); then
                    service_manager="systemctl"
                else
                    service_manager="service"
                fi
                ;;
            *)
                echo -e "${RED}不支持的系统${NC}"
                return 1
                ;;
        esac
    else
        echo -e "${RED}无法识别的系统${NC}"
        return 1
    fi
}

# 软件安装模块
install_xray() {
    echo "安装 Xray..."
    apt-get update && apt-get install unzip -y || yum install unzip -y

    wget -q https://github.com/XTLS/Xray-core/releases/download/v1.8.3/Xray-linux-64.zip -O /tmp/xray.zip
    if [ $? -ne 0 ]; then
        echo -e "${RED}下载 Xray 失败${NC}"
        return 1
    fi

    unzip -o /tmp/xray.zip -d /tmp/xray_temp
    if [ $? -ne 0 ]; then
        echo -e "${RED}解压 Xray 失败${NC}"
        return 1
    fi

    mv /tmp/xray_temp/xray /usr/local/bin/xrayL
    chmod +x /usr/local/bin/xrayL
    rm -rf /tmp/xray_temp /tmp/xray.zip

    mkdir -p /etc/xrayL

    cat <<EOF >/etc/systemd/system/xrayL.service
[Unit]
Description=XrayL Service
After=network.target

[Service]
ExecStart=/usr/local/bin/xrayL -c /etc/xrayL/config.toml
Restart=on-failure
User=nobody
RestartSec=3

[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload
    systemctl enable xrayL.service
    systemctl start xrayL.service

    if systemctl status xrayL.service | grep -q "running"; then
        echo "Xray 安装并启动完成."
    else
        echo -e "${RED}Xray 服务未能成功启动，请检查日志。${NC}"
        journalctl -u xrayL.service -n 20 --no-pager
    fi
}

# 环境配置模块
setup_environment() {
    echo "设置防火墙规则..."
    iptables -P INPUT ACCEPT
    iptables -P FORWARD ACCEPT
    iptables -P OUTPUT ACCEPT
    iptables -t nat -F
    iptables -t mangle -F
    iptables -F
    iptables -X
    iptables-save

    install_xray
    echo "环境配置完成。"
    return 0
}

# IPv6相关函数
generate_random_hex() {
    local length=$1
    head -c $((length/2)) /dev/urandom | hexdump -ve '1/1 "%.2x"'
}

get_main_interface() {
    MAIN_INTERFACE=$(ip route | grep default | awk '{print $5}' | head -n1)
    if [ -z "$MAIN_INTERFACE" ]; then
        echo -e "${RED}错误: 无法检测到主网卡${NC}"
        return 1
    fi
    echo $MAIN_INTERFACE
}

get_ipv6_prefix() {
    local interface=$1
    local current_ipv6=$(ip -6 addr show dev $interface | grep "scope global" | grep -v "temporary" | head -n1 | awk '{print $2}')

    if [ -z "$current_ipv6" ]; then
        echo -e "${RED}错误: 未检测到IPv6地址${NC}" >&2
        return 1
    fi

    local ipv6_addr=$(echo "$current_ipv6" | cut -d'/' -f1)
    local prefix=$(echo "$ipv6_addr" | sed -E 's/:[^:]+:[^:]+:[^:]+:[^:]+$/::/')

    if [ -z "$prefix" ]; then
        echo -e "${RED}错误: 无法提取IPv6前缀${NC}" >&2
        return 1
    fi

    echo "$prefix"
}

add_random_ipv6() {
    local num=$1
    local interface=$(get_main_interface)
    if [ $? -ne 0 ]; then
        return 1
    fi

    local prefix=$(get_ipv6_prefix "$interface")
    if [ $? -ne 0 ]; then
        return 1
    fi

    echo -e "${YELLOW}准备添加IPv6地址:${NC}"
    echo "使用网络接口: $interface"
    echo "使用IPv6前缀: $prefix"
    echo "计划添加数量: $num"

    local count=0
    local attempts=0
    local max_attempts=$((num * 3))

    while [ $count -lt $num ] && [ $attempts -lt $max_attempts ]; do
        ((attempts++))
        local suffix=$(printf "%04x:%04x:%04x:%04x" \
            $((RANDOM % 65536)) \
            $((RANDOM % 65536)) \
            $((RANDOM % 65536)) \
            $((RANDOM % 65536)))

        local NEW_IPV6="${prefix%::}:${suffix}"

        echo -e "\n${YELLOW}尝试添加新地址: $NEW_IPV6${NC}"
        if ip -6 addr add "$NEW_IPV6/64" dev "$interface" 2>/dev/null; then
            echo -e "${GREEN}成功添加IPv6地址: $NEW_IPV6${NC}"
            ((count++))

            # 创建持久化配置
            mkdir -p /etc/network/interfaces.d
            echo "iface $interface inet6 static" >> /etc/network/interfaces.d/60-ipv6-addresses
            echo "    address $NEW_IPV6/64" >> /etc/network/interfaces.d/60-ipv6-addresses
            echo "" >> /etc/network/interfaces.d/60-ipv6-addresses
        else
            echo -e "${RED}添加地址失败: $NEW_IPV6${NC}"
        fi
    done

    if [ $count -lt $num ]; then
        echo -e "${RED}警告: 只成功添加了 $count 个地址（目标: $num）${NC}"
    fi

    show_current_ipv6 "$interface"
}

delete_all_ipv6() {
    local interface=$(get_main_interface)
    if [ $? -ne 0 ]; then
        return 1
    fi

    local CONFIG_FILE="/etc/network/interfaces.d/60-ipv6-addresses"
    if [ -f "$CONFIG_FILE" ]; then
        rm -f "$CONFIG_FILE"
        echo -e "${GREEN}已删除配置文件${NC}"
    fi

    for addr in $(ip -6 addr show dev "$interface" | grep "inet6" | grep -v "fe80" | awk '{print $2}'); do
        ip -6 addr del "$addr" dev "$interface"
        echo -e "${YELLOW}已删除IPv6地址: $addr${NC}"
    done

    echo -e "${GREEN}所有配置的IPv6地址已删除${NC}"
}

show_current_ipv6() {
    local interface=$1
    echo -e "${YELLOW}当前IPv6地址列表：${NC}"
    local ipv6_list=$(ip -6 addr show dev "$interface" | grep "inet6" | grep -v "fe80")
    if [ -z "$ipv6_list" ]; then
        echo -e "${RED}未检测到任何IPv6地址${NC}"
        return 1
    fi
    echo "$ipv6_list"
}

# 带宽控制功能
setup_bandwidth_control() {
    echo -e "${YELLOW}配置带宽控制...${NC}"
    
    local interfaces=$(ip -o link show | awk -F': ' '$2 != "lo" {print $2}')
    
    echo "检测到的网络接口："
    echo "$interfaces"
    
    read -p "请输入要限制的总带宽(Mbps): " bandwidth
    
    if ! [[ "$bandwidth" =~ ^[0-9]+$ ]]; then
        echo -e "${RED}请输入有效的数字${NC}"
        return 1
    fi

    for interface in $interfaces; do
        tc qdisc del dev "$interface" root 2>/dev/null
        tc qdisc add dev "$interface" root handle 1: htb default 10
        tc class add dev "$interface" parent 1: classid 1:1 htb rate "${bandwidth}mbit" ceil "${bandwidth}mbit"
        tc class add dev "$interface" parent 1:1 classid 1:10 htb rate "${bandwidth}mbit" ceil "${bandwidth}mbit"
        
        echo -e "${GREEN}接口 $interface 带宽已限制为 ${bandwidth}Mbps${NC}"
    done
}

# BBR加速功能
enable_bbr() {
    echo -e "${YELLOW}正在配置BBR...${NC}"
    
    if lsmod | grep -q bbr; then
        echo -e "${GREEN}BBR 已经启用${NC}"
        return 0
    fi
    
    if [[ $(uname -r | cut -d. -f1) -lt 4 ]]; then
        echo -e "${RED}当前内核版本不支持BBR，需要4.9或更高版本${NC}"
        return 1
    fi

    cat >> /etc/sysctl.conf <<EOF
net.core.default_qdisc=fq
net.ipv4.tcp_congestion_control=bbr
EOF

    sysctl -p

    if sysctl net.ipv4.tcp_congestion_control | grep -q bbr; then
        echo -e "${GREEN}BBR 配置成功${NC}"
    else
        echo -e "${RED}BBR 配置失败${NC}"
    fi
}

# 代理配置和IP策略的组合配置函数
configure_proxy_and_strategy() {
    echo -e "${YELLOW}配置代理服务和IP策略${NC}"
    
    # 选择代理类型
    echo "1. SOCKS5代理"
    echo "2. VMESS代理"
    read -p "请选择代理类型 [1-2]: " proxy_type
    
    # 选择IP策略
    echo -e "\n请选择IP进出策略："
    echo "1. 同IP进同IP出（默认）"
    echo "2. IPv4进随机IPv4出（不重复直到耗尽）"
    echo "3. IPv4进随机IPv6出（不重复直到耗尽）"
    echo "4. IPv4进，不同端口对应固定IPv6出（自动分配）"
    read -p "请选择策略 [1-4]: " strategy
    
    # 获取基本配置
    read -p "起始端口 (默认 $DEFAULT_START_PORT): " START_PORT
    START_PORT=${START_PORT:-$DEFAULT_START_PORT}
    
    case $proxy_type in
        1) 
            read -p "SOCKS 账号 (默认 $DEFAULT_SOCKS_USERNAME): " SOCKS_USERNAME
            SOCKS_USERNAME=${SOCKS_USERNAME:-$DEFAULT_SOCKS_USERNAME}
            read -p "SOCKS 密码 (默认 $DEFAULT_SOCKS_PASSWORD): " SOCKS_PASSWORD
            SOCKS_PASSWORD=${SOCKS_PASSWORD:-$DEFAULT_SOCKS_PASSWORD}
            PROXY_TYPE="socks"
            ;;
        2)
            read -p "UUID (默认随机): " UUID
            UUID=${UUID:-$DEFAULT_UUID}
            read -p "WebSocket 路径 (默认 $DEFAULT_WS_PATH): " WS_PATH
            WS_PATH=${WS_PATH:-$DEFAULT_WS_PATH}
            PROXY_TYPE="vmess"
            ;;
        *)
            echo -e "${RED}无效的代理类型选择${NC}"
            return 1
            ;;
    esac
    
    # 清除现有配置
    rm -f /etc/xrayL/config.toml
    rm -rf /etc/xrayL/track
    mkdir -p /etc/xrayL/track
    
    # 获取当前可用的IP地址
    IPV4_ADDRESSES=($(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | grep -v '^127\.'))
    IPV6_ADDRESSES=($(ip -6 addr show | grep "inet6" | grep "scope global" | grep -v "temporary" | awk '{print $2}' | cut -d'/' -f1))

    # 验证IP地址可用性
    if [ ${#IPV4_ADDRESSES[@]} -eq 0 ]; then
        echo -e "${RED}错误: 未检测到可用的IPv4地址${NC}"
        return 1
    fi

    if [ "$strategy" = "3" ] || [ "$strategy" = "4" ]; then
        if [ ${#IPV6_ADDRESSES[@]} -eq 0 ]; then
            echo -e "${RED}错误: 未检测到可用的IPv6地址，无法使用IPv6策略${NC}"
            return 1
        fi
    fi
    
    # 根据选择的策略生成配置
    case $strategy in
        1) config_same_ip_strategy ;;
        2) config_random_ipv4_strategy ;;
        3) config_random_ipv6_strategy ;;
        4) config_fixed_ipv6_strategy ;;
        *) 
            echo -e "${RED}无效的策略选择${NC}"
            return 1
            ;;
    esac
    
    # 重启服务
    systemctl restart xrayL
    
    # 生成代理列表
    generate_proxy_list "$START_PORT" "$PROXY_TYPE" "$SOCKS_USERNAME" "$SOCKS_PASSWORD" "$UUID" "$WS_PATH"
    
    echo -e "${GREEN}配置完成${NC}"
}

# 同IP进出策略
config_same_ip_strategy() {
    local config=""
    local port=$START_PORT
    
    for ip in "${IPV4_ADDRESSES[@]}"; do
        if [ "$PROXY_TYPE" == "socks" ]; then
            config+=$(cat <<EOF
[[inbounds]]
listen = "$ip"
port = $port
protocol = "socks"
tag = "in_$ip"
[ inbounds.settings ]
auth = "password"
udp = true
[[ inbounds.settings.accounts ]]
user = "$SOCKS_USERNAME"
pass = "$SOCKS_PASSWORD"

[[outbounds]]
protocol = "freedom"
tag = "out_$ip"
[ outbounds.settings ]
domainStrategy = "UseIPv4"

[[routing.rules]]
type = "field"
inboundTag = ["in_$ip"]
outboundTag = "out_$ip"

EOF
)
        else
            config+=$(cat <<EOF
[[inbounds]]
listen = "$ip"
port = $port
protocol = "vmess"
tag = "in_$ip"
[ inbounds.settings ]
[[ inbounds.settings.clients ]]
id = "$UUID"
[ inbounds.streamSettings ]
network = "ws"
[ inbounds.streamSettings.wsSettings ]
path = "$WS_PATH"

[[outbounds]]
protocol = "freedom"
tag = "out_$ip"
[ outbounds.settings ]
domainStrategy = "UseIPv4"

[[routing.rules]]
type = "field"
inboundTag = ["in_$ip"]
outboundTag = "out_$ip"

EOF
)
        fi

        ((port++))
    done
    
    echo -e "$config" > /etc/xrayL/config.toml
}

# IPv4进随机IPv4出策略
config_random_ipv4_strategy() {
    # 创建IP选择脚本
    cat <<'EOF' > /etc/xrayL/track/select_next_ipv4.sh
#!/bin/bash
TRACK_DIR="/etc/xrayL/track"
IP_USED="$TRACK_DIR/ipv4_used.txt"
LOCK_FILE="$TRACK_DIR/ipv4.lock"

exec 200>$LOCK_FILE
flock -n 200 || exit 1

all_ips=($(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | grep -v '^127\.'))
[ ! -f "$IP_USED" ] && touch "$IP_USED"
used_ips=($(cat "$IP_USED"))

[ ${#used_ips[@]} -ge ${#all_ips[@]} ] && echo -n "" > "$IP_USED" && used_ips=()

for ip in "${all_ips[@]}"; do
    if [[ ! " ${used_ips[*]} " =~ " ${ip} " ]]; then
        echo "$ip" >> "$IP_USED"
        echo "$ip"
        exit 0
    fi
done

echo "${all_ips[0]}"
EOF
    chmod +x /etc/xrayL/track/select_next_ipv4.sh

    local config=""
    local port=$START_PORT
    
    for ip in "${IPV4_ADDRESSES[@]}"; do
        if [ "$PROXY_TYPE" == "socks" ]; then
            config+=$(cat <<EOF
[[inbounds]]
listen = "$ip"
port = $port
protocol = "socks"
tag = "in_$ip"
[ inbounds.settings ]
auth = "password"
udp = true
[[ inbounds.settings.accounts ]]
user = "$SOCKS_USERNAME"
pass = "$SOCKS_PASSWORD"

EOF
)
        else
            config+=$(cat <<EOF
[[inbounds]]
listen = "$ip"
port = $port
protocol = "vmess"
tag = "in_$ip"
[ inbounds.settings ]
[[ inbounds.settings.clients ]]
id = "$UUID"
[ inbounds.streamSettings ]
network = "ws"
[ inbounds.streamSettings.wsSettings ]
path = "$WS_PATH"

EOF
)
        fi
        ((port++))
    done

    # 定义随机IP的出站
    config+=$(cat <<EOF
[[outbounds]]
protocol = "freedom"
tag = "random_out"
[ outbounds.settings ]
domainStrategy = "UseIPv4"

[[routing.rules]]
type = "field"
outboundTag = "random_out"

EOF
)
    echo -e "$config" > /etc/xrayL/config.toml
}

# IPv4进随机IPv6出策略
config_random_ipv6_strategy() {
    # 创建IPv6选择脚本
    cat <<'EOF' > /etc/xrayL/track/select_next_ipv6.sh
#!/bin/bash
TRACK_DIR="/etc/xrayL/track"
IP_USED="$TRACK_DIR/ipv6_used.txt"
LOCK_FILE="$TRACK_DIR/ipv6.lock"

exec 200>$LOCK_FILE
flock -n 200 || exit 1

all_ips=($(ip -6 addr show | grep "inet6" | grep "scope global" | grep -v "temporary" | awk '{print $2}' | cut -d'/' -f1))
[ ! -f "$IP_USED" ] && touch "$IP_USED"
used_ips=($(cat "$IP_USED"))

[ ${#used_ips[@]} -ge ${#all_ips[@]} ] && echo -n "" > "$IP_USED" && used_ips=()

for ip in "${all_ips[@]}"; do
    if [[ ! " ${used_ips[*]} " =~ " ${ip} " ]]; then
        echo "$ip" >> "$IP_USED"
        echo "$ip"
        exit 0
    fi
done

echo "${all_ips[0]}"
EOF
    chmod +x /etc/xrayL/track/select_next_ipv6.sh

    local config=""
    local port=$START_PORT
    
    for ip in "${IPV4_ADDRESSES[@]}"; do
        if [ "$PROXY_TYPE" == "socks" ]; then
            config+=$(cat <<EOF
[[inbounds]]
listen = "$ip"
port = $port
protocol = "socks"
tag = "in_$ip"
[ inbounds.settings ]
auth = "password"
udp = true
[[ inbounds.settings.accounts ]]
user = "$SOCKS_USERNAME"
pass = "$SOCKS_PASSWORD"

EOF
)
        else
            config+=$(cat <<EOF
[[inbounds]]
listen = "$ip"
port = $port
protocol = "vmess"
tag = "in_$ip"
[ inbounds.settings ]
[[ inbounds.settings.clients ]]
id = "$UUID"
[ inbounds.streamSettings ]
network = "ws"
[ inbounds.streamSettings.wsSettings ]
path = "$WS_PATH"

EOF
)
        fi
        ((port++))
    done

    # 定义随机IPv6的出站
    config+=$(cat <<EOF
[[outbounds]]
protocol = "freedom"
tag = "random_ipv6_out"
[ outbounds.settings ]
domainStrategy = "UseIPv6"

[[routing.rules]]
type = "field"
outboundTag = "random_ipv6_out"

EOF
)
    echo -e "$config" > /etc/xrayL/config.toml
}

# IPv4进固定IPv6出策略
config_fixed_ipv6_strategy() {
    local config=""
    local port=$START_PORT
    local ipv6_index=0
    
    for ip in "${IPV4_ADDRESSES[@]}"; do
        if [ $ipv6_index -lt ${#IPV6_ADDRESSES[@]} ]; then
            local fixed_ipv6="${IPV6_ADDRESSES[$ipv6_index]}"
            
            if [ "$PROXY_TYPE" == "socks" ]; then
                config+=$(cat <<EOF
[[inbounds]]
listen = "$ip"
port = $port
protocol = "socks"
tag = "in_$ip"
[ inbounds.settings ]
auth = "password"
udp = true
[[ inbounds.settings.accounts ]]
user = "$SOCKS_USERNAME"
pass = "$SOCKS_PASSWORD"

[[outbounds]]
protocol = "freedom"
tag = "out_$ip"
[ outbounds.settings ]
domainStrategy = "UseIPv6"

[[routing.rules]]
type = "field"
inboundTag = ["in_$ip"]
outboundTag = "out_$ip"

EOF
)
            else
                config+=$(cat <<EOF
[[inbounds]]
listen = "$ip"
port = $port
protocol = "vmess"
tag = "in_$ip"
[ inbounds.settings ]
[[ inbounds.settings.clients ]]
id = "$UUID"
[ inbounds.streamSettings ]
network = "ws"
[ inbounds.streamSettings.wsSettings ]
path = "$WS_PATH"

[[outbounds]]
protocol = "freedom"
tag = "out_$ip"
[ outbounds.settings ]
domainStrategy = "UseIPv6"

[[routing.rules]]
type = "field"
inboundTag = ["in_$ip"]
outboundTag = "out_$ip"

EOF
)
            fi

            ((ipv6_index++))
            ((port++))
        fi
    done
    
    echo -e "$config" > /etc/xrayL/config.toml
}

# 生成代理列表
generate_proxy_list() {
    local start_port=$1
    local type=$2
    local username=$3
    local password=$4
    local uuid=$5
    local ws_path=$6

    echo -n "" > /root/proxy_list.txt
    local port=$start_port

    # 添加IPv4代理
    for ip in "${IPV4_ADDRESSES[@]}"; do
        if [ "$type" == "socks" ]; then
            echo "${ip}:${port}:${username}:${password}" >> /root/proxy_list.txt
        else
            # 生成标准VMess URI
            local vmess_json=$(jq -n \
                --arg id "$uuid" \
                --arg alterId "0" \
                --arg security "auto" \
                --arg network "ws" \
                --arg ws_path "$ws_path" \
                '{
                    v: "2",
                    ps: "",
                    add: $ip,
                    port: "$port",
                    id: $id,
                    aid: $alterId,
                    net: $network,
                    type: "none",
                    host: "",
                    path: $ws_path,
                    tls: ""
                }')
            local vmess_base64=$(echo -n "$vmess_json" | base64 -w0)
            echo "vmess://$vmess_base64" >> /root/proxy_list.txt
        fi
        ((port++))
    done

    echo -e "${GREEN}代理列表已生成：/root/proxy_list.txt${NC}"
}

# 连通性测试
test_proxy_connectivity() {
    echo -e "${YELLOW}测试代理连通性...${NC}"
    
    if [ ! -f /root/proxy_list.txt ]; then
        echo -e "${RED}代理列表文件不存在${NC}"
        return 1
    fi
    
    if ! command -v curl &> /dev/null; then
        echo "安装curl..."
        apt-get update && apt-get install -y curl || yum install -y curl
    fi
    
    if ! command -v nc &> /dev/null; then
        echo "安装netcat..."
        apt-get update && apt-get install -y netcat || yum install -y nc
    fi
    
    while IFS=: read -r ip port user pass; do
        if [[ $ip == vmess* ]]; then
            echo -e "\n${YELLOW}VMess代理暂不支持自动测试${NC}"
            continue
        fi
        
        echo -e "\n${YELLOW}测试代理: $ip:$port${NC}"
        
        # 处理IPv6地址
        if [[ $ip =~ .*:.* ]]; then
            test_ip="[$ip]"
        else
            test_ip="$ip"
        fi
        
        # 首先测试端口是否开放
        if ! nc -zv -w 5 "$ip" "$port" 2>/dev/null; then
            echo -e "${RED}端口 $port 未开放${NC}"
            continue
        fi
        
        # 使用多个测试网站
        local test_urls=(
            "http://www.google.com"
            "http://www.youtube.com"
            "http://www.facebook.com"
        )
        
        local success=false
        for url in "${test_urls[@]}"; do
            echo -e "测试访问 $url..."
            if curl -sx "socks5://$user:$pass@$test_ip:$port" \
                   -m 10 \
                   --connect-timeout 5 \
                   -IL "$url" 2>/dev/null | grep -q "HTTP/"; then
                echo -e "${GREEN}✓ 代理工作正常${NC}"
                success=true
                break
            fi
        done
        
        if ! $success; then
            echo -e "${RED}× 代理连接失败${NC}"
            echo -e "${YELLOW}请手动验证代理配置${NC}"
        fi
        
        # 添加延时避免过快测试
        sleep 1
    done < /root/proxy_list.txt
}

# 清理功能
clear_proxy_rules() {
    echo -e "${YELLOW}清理所有代理规则...${NC}"
    
    # 停止服务
    systemctl stop xrayL
    systemctl disable xrayL
    
    # 删除配置文件
    rm -f /etc/xrayL/config.toml
    rm -f /etc/systemd/system/xrayL.service
    rm -rf /etc/xrayL
    
    # 清除防火墙规则
    iptables -F
    iptables -X
    iptables -t nat -F
    iptables -t mangle -F
    
    # 清除带宽限制
    for interface in $(ip -o link show | awk -F': ' '$2 != "lo" {print $2}'); do
        tc qdisc del dev "$interface" root 2>/dev/null
    done
    
    # 删除代理列表
    rm -f /root/proxy_list.txt
    
    # 删除IPv6配置
    rm -f /etc/network/interfaces.d/60-ipv6-addresses
    
    echo -e "${GREEN}所有代理规则已清除${NC}"
}

# IPv6管理菜单
ipv6_manager_menu() {
    while true; do
        echo -e "\n${YELLOW}IPv6地址管理${NC}"
        echo "1. 添加随机IPv6地址"
        echo "2. 删除所有IPv6地址"
        echo "3. 显示当前IPv6地址"
        echo "4. 返回主菜单"
        
        read -p "请选择操作 [1-4]: " choice
        
        case $choice in
            1)
                read -p "请输入要添加的IPv6地址数量: " num
                if ! [[ "$num" =~ ^[0-9]+$ ]]; then
                    echo -e "${RED}请输入有效的数字${NC}"
                    continue
                fi
                add_random_ipv6 "$num"
                ;;
            2)
                delete_all_ipv6
                ;;
            3)
                local interface=$(get_main_interface)
                if [ $? -eq 0 ]; then
                    show_current_ipv6 "$interface"
                fi
                ;;
            4)
                return
                ;;
            *)
                echo -e "${RED}无效选择${NC}"
                ;;
        esac
    done
}

# 主菜单
show_menu() {
    echo -e "\n${YELLOW}=== 代理服务器管理工具 ===${NC}"
    echo "1. 环境配置（安装必要组件）"
    echo "2. 启用BBR加速"
    echo "3. IPv6地址管理"
    echo "4. 设置带宽控制"
    echo "5. 配置代理服务和IP策略"
    echo "6. 测试代理连通性"
    echo "7. 显示代理列表"
    echo "8. 清除所有代理规则"
    echo "9. 退出"

    read -p "请输入选项 [1-9]: " option
    case $option in
        1) setup_environment ;;
        2) enable_bbr ;;
        3) ipv6_manager_menu ;;
        4) setup_bandwidth_control ;;
        5) configure_proxy_and_strategy ;;
        6) test_proxy_connectivity ;;
        7) 
            if [ -f /root/proxy_list.txt ]; then
                cat /root/proxy_list.txt
            else
                echo -e "${RED}/root/proxy_list.txt 文件不存在。${NC}"
            fi
            ;;
        8) clear_proxy_rules ;;
        9) echo "退出脚本。"; exit ;;
        *) echo -e "${RED}无效选项，请输入1-9之间的数字${NC}" ;;
    esac
}

# 主函数
main() {
    # 检查root权限
    if [ "$EUID" -ne 0 ]; then 
        echo -e "${RED}请使用root权限运行此脚本${NC}"
        exit 1
    fi

    # 初始化
    detect_system
    if [ $? -ne 0 ]; then
        echo -e "${RED}系统检测失败，请检查您的操作系统是否受支持。${NC}"
        exit 1
    fi

    # 显示使用说明
    show_usage

    # 主循环
    while true; do
        show_menu
        sleep 1
    done
}

# 运行主程序
main "$@"
