#!/bin/bash

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 系统检测模块
detect_system() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        case "$ID" in
            "ubuntu"|"debian")
                service_manager="systemctl"
                ;;
            "centos")
                if [ "$VERSION_ID" -ge 7 ]; then
                    service_manager="systemctl"
                else
                    service_manager="service"
                fi
                ;;
            *)
                echo "不支持的系统"
                return 1
                ;;
        esac
    else
        echo "无法识别的系统"
        return 1
    fi
}

# 软件安装模块
check_and_install_unzip() {
    if ! command -v unzip &> /dev/null; then
        echo "未安装unzip，正在安装..."
        if [ "$ID" == "centos" ]; then
            sudo yum install unzip -y
        else
            sudo apt-get install unzip -y
        fi
    fi
    return 0
}

check_and_install_iptables() {
    if ! command -v iptables &> /dev/null; then
        echo "未安装iptables，正在安装..."
        if [ "$ID" == "centos" ]; then
            sudo yum install iptables-services -y
            sudo systemctl enable iptables
        else
            sudo apt-get install iptables-persistent -y
        fi
    fi
    return 0
}

# 系统检查模块
check_ipv6() {
    if ! sysctl -a 2>/dev/null | grep -q "net.ipv6.conf.all.disable_ipv6 = 0"; then
        echo "启用IPv6支持..."
        sysctl -w net.ipv6.conf.all.disable_ipv6=0
        sysctl -w net.ipv6.conf.default.disable_ipv6=0
        echo "net.ipv6.conf.all.disable_ipv6 = 0" >> /etc/sysctl.conf
        echo "net.ipv6.conf.default.disable_ipv6 = 0" >> /etc/sysctl.conf
        sysctl -p
    fi
    return 0
}

# 环境配置模块
setup_environment() {
    echo "设置防火墙规则..."
    iptables -P INPUT ACCEPT
    iptables -P FORWARD ACCEPT
    iptables -P OUTPUT ACCEPT
    iptables -t nat -F
    iptables -t mangle -F
    iptables -F
    iptables -X
    iptables-save

    install_xray
    echo "创建Xray服务文件..."
    cat <<EOF > /etc/systemd/system/xray.service
[Unit]
Description=The Xray Proxy Server
After=network-online.target
[Service]
ExecStart=/usr/local/bin/xray -c /etc/xray/serve.toml
ExecStop=/bin/kill -s QUIT \$MAINPID
Restart=always
RestartSec=15s
[Install]
WantedBy=multi-user.target
EOF

    echo "启动Xray服务..."
    $service_manager daemon-reload
    $service_manager enable xray
    $service_manager start xray
    echo "环境配置完成。"
    return 0
}

install_xray() {
    echo "正在从GitHub下载Xray..."
    check_and_install_unzip
    wget --no-check-certificate -O /usr/local/bin/xray.zip "https://github.com/XTLS/Xray-core/releases/latest/download/Xray-linux-64.zip"
    unzip /usr/local/bin/xray.zip -d /usr/local/bin
    rm /usr/local/bin/xray.zip
    chmod +x /usr/local/bin/xray
    echo "Xray已下载并设置为可执行。"
    return 0
}

# IPv6管理模块
#----------------------------------------

# 生成随机十六进制数
generate_random_hex() {
    local length=$1
    head -c $((length/2)) /dev/urandom | hexdump -ve '1/1 "%.2x"'
}

# 获取主网卡接口
get_main_interface() {
    MAIN_INTERFACE=$(ip route | grep default | awk '{print $5}' | head -n1)
    if [ -z "$MAIN_INTERFACE" ]; then
        echo -e "${RED}错误: 无法检测到主网卡${NC}"
        exit 1
    fi
    echo $MAIN_INTERFACE
}

# 获取IPv6前缀
get_ipv6_prefix() {
    local interface=$1
    IPV6_PREFIX=$(ip -6 addr show dev $interface | grep -v fe80 | grep -v fd00 | grep inet6 | head -n1 | awk '{print $2}' | cut -d'/' -f1 | sed 's/:[^:]*$/::/')
    if [ -z "$IPV6_PREFIX" ]; then
        echo -e "${RED}错误: 未检测到IPv6地址${NC}"
        return 1
    fi
    echo $IPV6_PREFIX
}

# 添加IPv6地址
add_ipv6_addresses() {
    local interface=$1
    local prefix=$2
    local num=$3
    local added_count=0
    
    # 创建配置文件目录
    mkdir -p /etc/network/interfaces.d/
    CONFIG_FILE="/etc/network/interfaces.d/60-ipv6-addresses"
    
    echo "# IPv6配置 - $(date)" > $CONFIG_FILE
    declare -A added_addresses

    echo "正在添加IPv6地址..."
    while [ $added_count -lt $num ]; do
        RANDOM_SUFFIX=$(generate_random_hex 16)
        NEW_IPV6="${prefix}${RANDOM_SUFFIX}"
        
        if [ -z "${added_addresses[$NEW_IPV6]}" ]; then
            if ip -6 addr add $NEW_IPV6/64 dev $interface 2>/dev/null; then
                added_addresses[$NEW_IPV6]=1
                echo "up ip -6 addr add $NEW_IPV6/64 dev $interface" >> $CONFIG_FILE
                echo -e "${GREEN}已添加IPv6地址: $NEW_IPV6${NC}"
                ((added_count++))
                
                # 验证地址是否成功添加
                if ! ip -6 addr show dev $interface | grep -q "$NEW_IPV6"; then
                    echo -e "${YELLOW}警告：地址可能未成功添加: $NEW_IPV6${NC}"
                    continue
                fi
            else
                echo -e "${RED}添加地址失败: $NEW_IPV6${NC}"
            fi
        fi
    done

    # 应用更改
    ip link set $interface down && ip link set $interface up
    sleep 2
    
    # 验证结果
    verify_ipv6_addresses $interface
    
    return 0
}

# 验证IPv6地址
verify_ipv6_addresses() {
    local interface=$1
    local count=0
    
    echo -e "\n${YELLOW}验证IPv6地址...${NC}"
    
    while read -r line; do
        if [[ $line =~ inet6[[:space:]]([a-f0-9:]+)/([0-9]+) ]]; then
            addr="${BASH_REMATCH[1]}"
            prefix="${BASH_REMATCH[2]}"
            if [[ $addr != fe80* ]]; then
                echo -e "${GREEN}地址: $addr${NC}"
                echo "前缀长度: $prefix"
                ((count++))
            fi
        fi
    done < <(ip -6 addr show dev $interface)
    
    echo -e "${YELLOW}总计: $count 个IPv6地址${NC}"
    return $count
}

# 删除所有IPv6地址
delete_all_ipv6() {
    local interface=$1
    local count=0
    
    echo "正在删除IPv6地址..."
    
    # 删除配置文件
    if [ -f "/etc/network/interfaces.d/60-ipv6-addresses" ]; then
        rm -f "/etc/network/interfaces.d/60-ipv6-addresses"
        echo -e "${GREEN}已删除配置文件${NC}"
    fi
    
    # 删除所有非本地IPv6地址
    while read -r line; do
        if [[ $line =~ inet6[[:space:]]([a-f0-9:]+)/([0-9]+) ]]; then
            addr="${BASH_REMATCH[1]}"
            if [[ $addr != fe80* ]]; then
                if ip -6 addr del "$addr/64" dev $interface 2>/dev/null; then
                    echo -e "${GREEN}已删除: $addr${NC}"
                    ((count++))
                fi
            fi
        fi
    done < <(ip -6 addr show dev $interface)
    
    echo -e "${YELLOW}总计删除了 $count 个IPv6地址${NC}"
    return 0
}

# 显示当前IPv6地址
show_current_ipv6() {
    local interface=$1
    local count=0
    
    echo -e "\n${YELLOW}当前IPv6地址列表：${NC}"
    
    while read -r line; do
        if [[ $line =~ inet6[[:space:]]([a-f0-9:]+)/([0-9]+) ]]; then
            addr="${BASH_REMATCH[1]}"
            prefix="${BASH_REMATCH[2]}"
            if [[ $addr != fe80* ]]; then
                echo -e "${GREEN}地址: $addr${NC}"
                echo "前缀长度: $prefix"
                echo "---"
                ((count++))
            fi
        fi
    done < <(ip -6 addr show dev $interface)
    
    if [ $count -eq 0 ]; then
        echo -e "${RED}未检测到任何IPv6地址${NC}"
        return 1
    fi
    
    echo -e "${YELLOW}总计: $count 个IPv6地址${NC}"
    return 0
}

# IP策略配置模块
set_ip_strategy() {
    echo "配置IP进出策略..."
    
    # 如果没有之前设置的信息，先获取
    if [ -z "$socks_port" ] || [ -z "$socks_user" ] || [ -z "$socks_pass" ]; then
        read -p "请输入SOCKS5起始端口: " socks_port
        read -p "请输入用户名: " socks_user
        read -p "请输入密码: " socks_pass
    fi
    
    # 获取当前IPv4和IPv6地址
    ipv4_addrs=($(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | grep -v '^127\.'))
    ipv6_addrs=($(ip -6 addr show | grep "inet6" | grep -v "fe80" | grep -v "::1" | awk '{print $2}' | cut -d'/' -f1))
    
    echo "当前IPv4地址: ${ipv4_addrs[@]}"
    echo "当前IPv6地址: ${ipv6_addrs[@]}"
    
    echo "请选择IP进出策略："
    echo "1. 同IP进同IP出（默认）"
    echo "2. IPv4进随机IPv4出（不重复直到耗尽）"
    echo "3. IPv4进随机IPv6出（不重复直到耗尽）"
    echo "4. IPv4进，自动分配端口对应IPv6出"
    read -p "请输入选项 [1-4]: " strategy

    case $strategy in
        4)
            echo "配置端口与IPv6地址的对应关系"
            read -p "请输入要配置的端口数量: " port_count
            
            if [ ${#ipv6_addrs[@]} -eq 0 ]; then
                echo -e "${RED}错误：未检测到可用的IPv6地址${NC}"
                return 1
            fi
            
            # 自动分配IPv6地址给端口
            declare -A port_ipv6_map
            ipv6_index=0
            for ((i=0; i<port_count; i++)); do
                current_port=$((socks_port + i))
                # 循环使用IPv6地址
                current_ipv6=${ipv6_addrs[$ipv6_index]}
                port_ipv6_map[$current_port]=$current_ipv6
                echo "端口 $current_port -> IPv6: $current_ipv6"
                
                # 更新IPv6索引，循环使用
                ipv6_index=$(( (ipv6_index + 1) % ${#ipv6_addrs[@]} ))
            done
            
            # 生成配置
            configure_ip_strategy $strategy port_ipv6_map
            ;;
        1|2|3)
            configure_ip_strategy $strategy
            ;;
        *)
            echo "无效选项，使用默认策略（同IP进出）"
            configure_ip_strategy 1
            ;;
    esac
}

# 配置IP策略
configure_ip_strategy() {
    local strategy=$1
    mkdir -p /etc/xray
    echo -n "" > /etc/xray/serve.toml

    case $strategy in
        1)  # 同IP进同IP出
            for ipv4 in "${ipv4_addrs[@]}"; do
                cat <<EOF >> /etc/xray/serve.toml
[[inbounds]]
listen = "$ipv4"
port = $socks_port
protocol = "socks"
tag = "in_$ipv4"
[inbounds.settings]
auth = "password"
udp = true
[[inbounds.settings.accounts]]
user = "$socks_user"
pass = "$socks_pass"

[[outbounds]]
protocol = "freedom"
tag = "out_$ipv4"
[outbounds.settings]
domainStrategy = "UseIPv4"
sendThrough = "$ipv4"

[[routing.rules]]
type = "field"
inboundTag = ["in_$ipv4"]
outboundTag = "out_$ipv4"

EOF
            done
            ;;
            
        2)  # IPv4进随机IPv4出
            mkdir -p /etc/xray/track
            
            # 配置入站
            for ipv4 in "${ipv4_addrs[@]}"; do
                cat <<EOF >> /etc/xray/serve.toml
[[inbounds]]
listen = "$ipv4"
port = $socks_port
protocol = "socks"
tag = "in_$ipv4"
[inbounds.settings]
auth = "password"
udp = true
[[inbounds.settings.accounts]]
user = "$socks_user"
pass = "$socks_pass"

EOF
            done

            # 创建IP选择脚本
            cat <<'EOF' > /etc/xray/track/select_next_ip.sh
#!/bin/bash
TRACK_DIR="/etc/xray/track"
IPV4_USED="$TRACK_DIR/ipv4_used.txt"

all_ipv4=($(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | grep -v '^127\.'))

if [ ! -s "$IPV4_USED" ]; then
    touch "$IPV4_USED"
fi

used_ips=($(cat "$IPV4_USED"))

if [ ${#used_ips[@]} -ge ${#all_ipv4[@]} ]; then
    echo -n "" > "$IPV4_USED"
    used_ips=()
fi

for ip in "${all_ipv4[@]}"; do
    if [[ ! " ${used_ips[*]} " =~ " ${ip} " ]]; then
        echo "$ip" >> "$IPV4_USED"
        echo "$ip"
        exit 0
    fi
done

echo "${all_ipv4[0]}"
EOF
            chmod +x /etc/xray/track/select_next_ip.sh

            # 配置出站
            next_ip=$(/etc/xray/track/select_next_ip.sh)
            cat <<EOF >> /etc/xray/serve.toml
[[outbounds]]
protocol = "freedom"
tag = "out"
[outbounds.settings]
domainStrategy = "UseIPv4"
sendThrough = "$next_ip"

[[routing.rules]]
type = "field"
network = ["tcp", "udp"]
outboundTag = "out"

EOF
            ;;

        3)  # IPv4进随机IPv6出
            mkdir -p /etc/xray/track
            
            # 配置入站
            for ipv4 in "${ipv4_addrs[@]}"; do
                cat <<EOF >> /etc/xray/serve.toml
[[inbounds]]
listen = "$ipv4"
port = $socks_port
protocol = "socks"
tag = "in_$ipv4"
[inbounds.settings]
auth = "password"
udp = true
[[inbounds.settings.accounts]]
user = "$socks_user"
pass = "$socks_pass"

EOF
            done

            # 创建IPv6选择脚本
            cat <<'EOF' > /etc/xray/track/select_next_ipv6.sh
#!/bin/bash
TRACK_DIR="/etc/xray/track"
IPV6_USED="$TRACK_DIR/ipv6_used.txt"

all_ipv6=($(ip -6 addr show | grep -oP '(?<=inet6\s)[\da-f:]+' | grep -v '^fe80' | grep -v '^::1'))

if [ ! -s "$IPV6_USED" ]; then
    touch "$IPV6_USED"
fi

used_ips=($(cat "$IPV6_USED"))

if [ ${#used_ips[@]} -ge ${#all_ipv6[@]} ]; then
    echo -n "" > "$IPV6_USED"
    used_ips=()
fi

for ip in "${all_ipv6[@]}"; do
    if [[ ! " ${used_ips[*]} " =~ " ${ip} " ]]; then
        echo "$ip" >> "$IPV6_USED"
        echo "$ip"
        exit 0
    fi
done

echo "${all_ipv6[0]}"
EOF
            chmod +x /etc/xray/track/select_next_ipv6.sh

            # 配置出站
            next_ipv6=$(/etc/xray/track/select_next_ipv6.sh)
            cat <<EOF >> /etc/xray/serve.toml
[[outbounds]]
protocol = "freedom"
tag = "out"
[outbounds.settings]
domainStrategy = "UseIPv6"
sendThrough = "$next_ipv6"

[[routing.rules]]
type = "field"
network = ["tcp", "udp"]
outboundTag = "out"

EOF
            ;;
            
        4)  # IPv4进，不同端口对应固定IPv6出
            local -n port_map=$2
            
            # 为每个IPv4配置所有端口的入站
            for ipv4 in "${ipv4_addrs[@]}"; do
                for port in "${!port_map[@]}"; do
                    cat <<EOF >> /etc/xray/serve.toml
[[inbounds]]
listen = "$ipv4"
port = $port
protocol = "socks"
tag = "in_${ipv4}_${port}"
[inbounds.settings]
auth = "password"
udp = true
[[inbounds.settings.accounts]]
user = "$socks_user"
pass = "$socks_pass"

EOF
                done
            done

            # 为每个端口配置对应的IPv6出站
            for port in "${!port_map[@]}"; do
                ipv6=${port_map[$port]}
                cat <<EOF >> /etc/xray/serve.toml
[[outbounds]]
protocol = "freedom"
tag = "out_${port}"
[outbounds.settings]
domainStrategy = "UseIPv6"
sendThrough = "$ipv6"

EOF
                # 添加路由规则
                for ipv4 in "${ipv4_addrs[@]}"; do
                    cat <<EOF >> /etc/xray/serve.toml
[[routing.rules]]
type = "field"
inboundTag = ["in_${ipv4}_${port}"]
outboundTag = "out_${port}"

EOF
                done
            done
            ;;
    esac

    # 检查配置文件
    if ! /usr/local/bin/xray -test -config /etc/xray/serve.toml; then
        echo "Xray 配置验证失败"
        return 1
    fi

    # 重启 Xray 服务
    systemctl restart xray
    sleep 2

    if ! systemctl is-active --quiet xray; then
        echo "Xray 服务启动失败"
        systemctl status xray
        return 1
    fi

    echo "IP策略设置完成并成功启动服务"
    return 0
}

# 代理管理模块
generate_proxy_list() {
    local socks_port=$1
    local socks_user=$2
    local socks_pass=$3
    local ips=($(hostname -I))
    echo "生成代理列表文件..."
    echo -n "" > /root/proxy_list.txt
    for ip in "${ips[@]}"; do
        echo "$ip:$socks_port:$socks_user:$socks_pass" >> /root/proxy_list.txt
    done
    echo "代理列表文件已生成：/root/proxy_list.txt"
    return 0
}

test_proxy_connectivity() {
    echo "测试代理连通性..."
    
    if [ ! -f /root/proxy_list.txt ]; then
        echo "/root/proxy_list.txt 文件不存在。"
        return 1
    fi

    while IFS= read -r line; do
        if [[ $line =~ ^(.+):([0-9]+):(.+):(.+)$ ]]; then
            ip="${BASH_REMATCH[1]}"
            port="${BASH_REMATCH[2]}"
            user="${BASH_REMATCH[3]}"
            pass="${BASH_REMATCH[4]}"
            
            echo "正在测试 $ip:$port..."
            
            if [[ $ip == *:* ]]; then
                ip="[$ip]"
            fi

            if curl -s --proxy socks5h://$user:$pass@$ip:$port http://httpbin.org/ip -o /dev/null; then
                echo "$ip:$port 代理连接成功"
            else
                echo "$ip:$port 代理连接失败"
            fi
        else
            echo "行格式不正确: $line"
        fi
    done < /root/proxy_list.txt

    echo "代理连通性测试完成。"
    return 0
}

# 带宽管理模块
setup_bandwidth_control() {
    get_active_interfaces
    get_active_ip_count

    read -p "请输入VPS的总带宽（例如50M）: " total_bandwidth

    if [[ ! $total_bandwidth =~ ^[0-9]+M$ ]]; then
        echo "ERROR: 输入格式错误，请输入类似'50M'的格式。"
        return 1
    fi

    if [ "$active_ip_count" -eq 0 ]; then
        echo "INFO: 没有活动的IP，跳过带宽设置。"
        return 0
    fi

    local rate=$(echo "${total_bandwidth%M} / $active_ip_count" | bc)Mbit

    echo "INFO: 设置带宽控制..."
    for interface in $interfaces; do
        tc qdisc del dev $interface root 2>/dev/null
        tc qdisc add dev $interface root handle 1: htb default 30
        tc class add dev $interface parent 1: classid 1:1 htb rate $total_bandwidth

        for ip in $(hostname -I); do
            tc class add dev $interface parent 1:1 classid 1:10 htb rate ${rate} ceil ${rate}
            tc filter add dev $interface protocol ip parent 1:0 prio 1 u32 match ip dst $ip flowid 1:10
        done
    done

    echo "INFO: 带宽控制设置完成。"
    return 0
}

# 主菜单
show_menu() {
    echo -e "\n${YELLOW}=== 代理服务器管理工具 ===${NC}"
    echo "1. 环境配置（安装必要组件）"
    echo "2. 启用BBR加速"
    echo "3. IPv6地址管理"
    echo "4. 设置带宽控制"
    echo "5. SOCKS5代理设置"
    echo "6. 设置IP进出策略"
    echo "7. 测试代理连通性"
    echo "8. 显示代理列表"
    echo "9. 清除所有代理规则"
    echo "10. 退出"
    
    read -p "请输入选项 [1-10]: " option
    case $option in
        1) setup_environment ;;
        2) enable_bbr ;;
        3) ipv6_manager_menu ;;
        4) setup_bandwidth_control ;;
        5) set_socks5_credentials ;;
        6) set_ip_strategy ;;
        7) test_proxy_connectivity ;;
        8) cat /root/proxy_list.txt ;;
        9) clear_proxy_rules ;;
        10) echo "退出脚本。"; exit ;;
        *) echo -e "${RED}无效选项，请输入1-10之间的数字${NC}" ;;
    esac
}

# 主程序
main() {
    # 检查root权限
    if [ "$EUID" -ne 0 ]; then 
        echo -e "${RED}请使用root权限运行此脚本${NC}"
        exit 1
    fi

    # 初始化
    detect_system
    check_and_install_iptables
    check_ipv6

    # 显示使用说明
    show_usage

    # 主循环
    while true; do
        show_menu
        sleep 1
    done
}

# 运行主程序
main
